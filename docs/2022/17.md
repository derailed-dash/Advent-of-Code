---
day: 17
title: Day 17
main_img:
  name: "Tetris"
  link: /assets/images/tetris.png
tags: 
  - name: classes
    link: /python/classes
  - name: sets
    link: /python/sets
---

## Page Navigation

- [Problem Intro](#problem-intro)
- [Part 1](#part-1)
- [Part 2](#part-2)
- [Results](#results)

## Problem Intro

I enjoyed this one. The previous two days were really tough for me, so it was nice to have a problem that my simple brain could see a way through. 

_We get to code some Tetris today!!_

We're told rocks are falling from the ceiling of a tall chamber of fixed width. The rocks resemble Tetris pieces! There are five different rock shapes.  With each rock that falls, the rock shape changes. The rock shapes follow a set sequence, and this sequence repeats indefinitely. Rocks always fall from a position that is 2 units from the left wall, and 3 units above highest rock that has fallen previously. (Or the floor.)

As rocks fall, they are blown left or right by jets of air from the sides.  The input data describes the sequence of the air jets, e.g.

```text
>>><<><>><<<>><>>><<<>>><<<><<<>><>><<>>
```

We're told this jet pattern repeats indefinitely. As rocks fall, they are pushed 1 unit left or right, then they descend 1 unit. A rock comes to rest in the step _after_ it has reached a position where it cannot descend any further. Another rocks starts to fall whenever the previous rock comes to rest.

## Part 1

**How many units tall will the tower of rocks be after 2022 rocks have stopped falling?**

First, a new concept: an _enumeration_. Here, I've created a `ShapeType` _enumeration_, that allows us to reference the various shape types by name:

```python
class ShapeType(Enum):
    HLINE =       {(0, 0), (1, 0), (2, 0), (3, 0)}
    PLUS =        {(1, 0), (0, 1), (1, 1), (2, 1), (1, 2)}
    BACKWARDS_L = {(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)}
    I =           {(0, 0), (0, 1), (0, 2), (0, 3)}
    SQUARE =      {(0, 0), (1, 0), (0, 1), (1, 1)}
```

Then, a `dict` to represent the possible movements of a `Shape`, i.e. left, right, or down:

```python
MOVE = {
    "<": (-1, 0),
    ">": (1, 0),
    "V": (0, -1)
}
```

Next, I create a `Point` class, which knows how to add a vector to return a new `Point`.

```python
@dataclass(frozen=True)
class Point():
    """ Point with x,y coordinates and knows how to add a vector to create a new Point. """
    x: int
    y: int
    
    def __add__(self, other):
        """ Add other point/vector to this point, returning new point """
        return Point(self.x + other.x, self.y + other.y)     
    
    def __repr__(self) -> str:
        return f"P({self.x},{self.y})"
```

Now a class that represents the current positions occupied by an instance of any given `Shape`:

```python
class Shape():
    """ Stores the points that make up this shape. 
    Has a factory method to create Shape instances based on shape type. """
    
    def __init__(self, points: set[Point], at_rest=False) -> None:
        self.points: set[Point] = points   # the points that make up the shape
        self.at_rest = at_rest
    
    @classmethod
    def create_shape_by_type(cls, shape_type: str, origin: Point):
        """ Factory method to create an instance of our shape.
        The shape points are offset by the supplied origin. """
        return cls({(Point(*coords) + origin) for coords in ShapeType[shape_type].value})

    @classmethod
    def create_shape_from_points(cls, points: set[Point], at_rest=False):
        """ Factory method to create an instance of our shape.
        The shape points are offset by the supplied origin. """
        return cls(points, at_rest)
    
    def __eq__(self, __o: object) -> bool:
        if isinstance(__o, Shape):
            if self.points == __o.points:
                return True
            else:
                return False
        else:
            return NotImplemented  
    
    def __hash__(self) -> int:
        return hash(repr(self))

    def __repr__(self) -> str:
        return f"Shape(at_rest={self.at_rest}, points={self.points}"
```

Some notes about this `Shape` class:
  - It stores a `set` of all the Points it occupies.
  - It has factory methods to create each shape, either by `ShapeType`, or by supplying a number of points. We use the latter to create a new shape whenever we move an existing shape.
  - Shapes are created with all their points added to a specified `_origin_` point.
  - The `Shape` is _hashable_, meaning a given instance of a `Shape` with a given set of unique attributes should return a unique but consistent _hash_. We need this if we want to store 
  `Shape` objects in a `set` and then perform any `set` algebra on our sets.

All the fun stuff happens in the `Tower` class:

```python
class Tower():
    WIDTH = 7
    LEFT_WALL_X = 0  
    RIGHT_WALL_X = LEFT_WALL_X + 7 + 1  # right wall at x=8
    OFFSET_X = 2 + 1  # objects start with left edge at x=3
    OFFSET_Y = 3 + 1  # new rocks have a gap of 3 above top of highest settled rock
    FLOOR_Y = 0
    
    # Printing characters
    FALLING = "@"
    AT_REST = "#"
    EMPTY = "."
    WALL = "|"
    FLOOR = "-"
    
    def __init__(self, jet_pattern: str) -> None:
        self._jet_pattern = itertools.cycle(enumerate(jet_pattern)) # infinite cycle
        self._shape_generator = itertools.cycle(enumerate(item.name for item in ShapeType))  # infinite cycle
        self.top = Tower.FLOOR_Y  # keep track of top of blocks
        self._all_at_rest_shapes: set[Shape] = set()
        self._all_at_rest_points: set[Point] = set() # tracking this for speed
    
    def _current_origin(self) -> Point:
        """ Rocks are dropped 2 from the left edge, and 3 above the current tallest settled rock. """
        return Point(Tower.LEFT_WALL_X + Tower.OFFSET_X, self.top + Tower.OFFSET_Y)
    
    def _next_shape(self):
        """ Get the next shape from the generator """
        return next(self._shape_generator)
    
    def _next_jet(self):
        """ Get the next jet blast from the generator """
        return next(self._jet_pattern)
    
    def drop_shape(self):
        shape_index, next_shape_type = self._next_shape()
        self.current_shape = Shape.create_shape_by_type(next_shape_type, self._current_origin())
            
        while True:
            jet_index, jet = self._next_jet()
            self._move_shape(jet)
            # print(self)
            if not self._move_shape("V"): # failed to move down
                self.top = max(self.top, max(point.y for point in self.current_shape.points))
                settled_shape = Shape.create_shape_from_points(self.current_shape.points, True)
                self._settle_shape(settled_shape)
                break
    
    def _settle_shape(self, shape: Shape):
        """ Add this shape to the settled sets """
        self._all_at_rest_shapes.add(shape)
        self._all_at_rest_points.update(shape.points)
    
    def _move_shape(self, direction) -> bool:
        """ Move a shape in the direction indicated. Return False if we can't move. """
        
        # Test against boundaries
        if direction == "<":
            shape_left_x = min(point.x for point in self.current_shape.points)
            if shape_left_x == Tower.LEFT_WALL_X + 1:
                return False # can't move left
            
        if direction == ">":
            shape_right_x = max(point.x for point in self.current_shape.points)
            if shape_right_x == Tower.RIGHT_WALL_X - 1:
                return False # can't move right
            
        if direction == "V":
            shape_bottom = min(point.y for point in self.current_shape.points)
            if shape_bottom == Tower.FLOOR_Y + 1:
                return False # can't move down
        
        # Move phase - test for collision
        candidate_points = {(point + Point(*MOVE[direction])) for point in self.current_shape.points}
        if self._all_at_rest_points & candidate_points: # If the candidate would intersect
            return False # Then this is not a valid posiiton
        else: # We can move there. Update our current shape position, by constructing a new shape a the new position
            self.current_shape = Shape.create_shape_from_points(candidate_points)
        return True
    
    def get_recent_formation(self) -> str:
        """ Covert last (top) 20 rows into a str representation. """
        rows = []
        min_y = max(0, self.top-20) # we want the last 20 lines
        for y in range(min_y, self.top+1):
            line = ""
            for x in range(Tower.LEFT_WALL_X, Tower.RIGHT_WALL_X):
                if Point(x,y) in self._all_at_rest_points:
                    line += Tower.AT_REST
                elif Point(x,y) in self.current_shape.points:
                    line += Tower.FALLING
                else:
                    line += Tower.EMPTY
            
            rows.append(line)
            
        return "\n".join(rows[::-1])
                   
    def __str__(self) -> str:
        rows = []
        top_for_vis = max(self.top, max(point.y for point in self.current_shape.points))
            
        for y in range(Tower.FLOOR_Y, top_for_vis + 1):
            line = f"{y:3d} "
            if y == Tower.FLOOR_Y:
                line += "+" + (Tower.FLOOR * Tower.WIDTH) + "+"
            else:            
                for x in range(Tower.LEFT_WALL_X, Tower.RIGHT_WALL_X + 1):
                    if x in (Tower.LEFT_WALL_X, Tower.RIGHT_WALL_X):
                        line += Tower.WALL
                    elif Point(x,y) in self._all_at_rest_points:
                        line += Tower.AT_REST
                    elif Point(x,y) in self.current_shape.points:
                        line += Tower.FALLING
                    else:
                        line += Tower.EMPTY
                    
            rows.append(line)
        
        return f"{repr(self)}:\n" + "\n".join(rows[::-1]) 

    def __repr__(self) -> str:
        return (f"Tower(height={self.top}, rested={len(self._all_at_rest_shapes)})")
```

Things to say about this:
  - It uses `itertools.cycle()` to infinitely iterate through the input jet pattern.
    We can always generate the next jet.
  - It uses `itertools.cycle()` to infinitely iterate through the ShapeTypes in order.
    We can always generate the next shape.
  - It stores all points for all at rest shapes as a `set`.
  - It stores the current top (y coordinate) of all the settled points.
  - It sets the origin for the next shape dropped.
  - It simulates dropping a shape with a `drop_shape()` method:
    - Creates the new shape at the appropriate origin `Point`, using the `Shape` constructor that takes a `ShapeType`.
    - Calls `_move_shape()` with _next_ jet.
    - Calls `_move_shape("V")` to move the shape down. 
      If we can't move down, settles the shape by adding current shape to `_all_at_rest_shapes`.
  - To move a shape:
    - Check if we can move left, right or down based on the current bounds; return if we can't.
    - If the bounds are okay, generate candidate points from the current shape, i.e. by creating a set of points one point to the left, or to the right, as required.
    - Check if candidate points _intersect_ with any settled points.  If so, we can't move there.
    - Otherwise, make a new shape from the candidate points.

Finally, we just need to run our `drop()` method 2022 times:

```python
def main():
    with open(INPUT_FILE, mode="rt") as f:
        data = f.read()

    # Part 1        
    tower = Tower(jet_pattern=data)
    for _ in range(2022):
        tower.drop_shape()
    
    print(f"Part 1: {repr(tower)}")
```

## Part 2

## Results