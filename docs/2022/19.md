---
day: 19
title: Day 19
main_img:
  name: "Coming Soon"
  link: /assets/images/coming_soon.jpg
tags: 
  - name: regex
    link: /python/regex
  - name: BFS
    link: /python/shortest_paths
  - name: dataclass
    link: /python/classes#dataclass
---

## Page Navigation

- [Problem Intro](#problem-intro)
- [Part 1](#part-1)
- [Part 2](#part-2)
- [Results](#results)

## Problem Intro

We would like to collect geodes.  In order to do so, we need:

- Geode-cracking robots, to release the geodes
- Obsidian-collecting robots
- Clay-collecting robots
- Ore-collecting robots; we start with one of these.

Timings:
- Each robot can collect one of its corresponding resource per minute.
- Our robot factory can assemble any robot from its requisite ingrediens in one minute.
  The resources are consumed at the beginning of any fabrication minute.

Our input contains blueprints for robot types. The input data looks like this:

```text
Blueprint 1: Each ore robot costs 4 ore. Each clay robot costs 2 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 2 ore and 7 obsidian.
Blueprint 2: Each ore robot costs 2 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 8 clay. Each geode robot costs 3 ore and 12 obsidian.
```

## Part 1

**Determine the quality level of each blueprint by multiplying that blueprint's ID number with the largest number of geodes that can be opened in 24 minutes using that blueprint. Calculate the sum of he quality levels of all the blueprints in your input data.**

Essentially, this problem is about calculating all the possible orders in which we can build robots in each blueprint, to determine the maximum number of geodes that can be obtained from each blueprint.

We can do this using a [BFS](/python/shortest_paths) to determine all possible states that can be achieved in the 24 minutes we've been given. With each minute that passes, we _flood fill_ to the possible states in the next minutes.

First, I'll create an [Enum](/python/enumerate) type for the mineral types. This is to make the code a bit more readable, to avoid any `str` typos, and to facilitate autocompletion.

```python
class MineralType(Enum):
    """ Enumerate mineral / robot types """
    ORE = "ore"
    CLAY = "clay"
    OBSIDIAN = "obsidian"
    GEODE = "geode"
```

Then I create a `Blueprint` class. It is simply a [dataclass](/python/classes#dataclass) that stores our blueprint ID, and a `dict` that stores the material cost to build a given robot. This is a _nested_ dictionary.

```python
@dataclass(frozen=True)
class Blueprint():
    """ Store blueprint ID, with a dict for each robot type, that in turn contains a nested dict
    of all mineral costs for that robot.  """
    id: int
    costs: dict # { "ore": {"ore": 4}, "obsidian": {"ore": 3, clay: 14}, ...}
    
    def get_max_cost(self, mineral: MineralType):
        """ Return the maximum cost of a given mineral type for all robots in this blueprint. """
        
        # If this robot does not contain a given mineral in the blueprint, return 0 for this mineral
        return max([self.costs[MineralType.ORE.value].get(mineral.value, 0), 
                    self.costs[MineralType.CLAY.value].get(mineral.value, 0), 
                    self.costs[MineralType.OBSIDIAN.value].get(mineral.value, 0), 
                    self.costs[MineralType.GEODE.value].get(mineral.value, 0)])
```

The interesting thing to note about this class is the `get_max_cost()` method. This looks at each bot type in turn, and then determines the maximum rate we can consume the specified mineral. I.e. because bots consume these minerals at different rates, and we want the rate that is highest. I use this later in optimising the solution. 

Now we can read in the input data:

```python
def parse_data(data: list[str]) -> list[Blueprint]:
    """ Read the input and return a list of Blueprint """
    pattern = re.compile(r"Each (\w+) robot costs (\d+) (\w+)(?: and (\d+) (\w+))*.")
    blueprints = []
    for line in data:
        blueprint_id = int(line.split(":")[0].split()[-1])
        costs = {}
        for matches in pattern.findall(line):
            robot = matches[0]
            minerals = {}
            for i in range(2, len(matches) + 1, 2):
                if matches[i]: # if not empty
                    minerals[matches[i]] = int(matches[i-1])
            
            costs[robot] = minerals
    
        blueprints.append(Blueprint(blueprint_id, costs))
    
    return blueprints  
```

- Getting the ID is trivial. We just split the current line at the `:`, then all the words before the `:` by space, and return the last value.  This is the ID. Convert it to an `int`.
- For the robots and their costs, we're using [regex](/python/regex).
  - A given robot either costs `x something`, or it costs `x something and y something-else`. So, in the regex, I've made the `and y something-else` an optional group. Also, I'm using `(?: whatever)` to define this optional group as a _non-capturing group_. That means that this repeating group doesn't itself get returned as a match. (But groups inside it do.)
  - We then grab each subsequent pair of matches to build our `dict` of `K:V` pairs, where `K` is the mineral required, and `V` is integer amount.

The rest of the solution is simply a BFS. It works by popping the current _state_ off the frontier, checking if we've used up all our time, and if we haven't, it adds all possible next states on to our frontier.  Those next states can only be from the following:

1. Do not build any robot; simply accumulate resources with the robots we have.
1. Build an ore robot.
1. Build a clay robot.
1. Build an obsidian robot.
1. Build a geode robot.

In each case, the subsequent state needs to:

- Decrease the time by 1.
- Increment the respective robot, where applicable.
- Decrement resources that were used to build a robot, if applicable.
- Increment the mineral levels, by a number equivalent to the number of robots of that type.

We'll need to track these states, so I've created a `State` class:

```python
@dataclass(frozen=True)
class State():
    t_remaining: int
    
    ore: int = 0   
    clay: int = 0
    obsidian: int = 0
    geode: int = 0

    ore_r: int = 1
    clay_r: int = 0
    obsidian_r: int = 0
    geode_r: int = 0
```

At last, we're ready to implement the actual BFS.  (Recall that I explain how BFS works [here](/python/shortest_paths).)

```python
def bfs(blueprint: Blueprint, state: State):
    best = 0
    frontier = deque([state])
    explored = set()

    max_ore_cost = blueprint.get_max_cost(MineralType.ORE)
    max_clay_cost = blueprint.get_max_cost(MineralType.CLAY)
    max_obsidian_cost = blueprint.get_max_cost(MineralType.OBSIDIAN)
    
    while frontier:
        state = frontier.popleft() # popleft for BFS; pop for DFS

        best = max(best, state.geode)
        if state.t_remaining == 0:
            continue
        
        # Optimise state space by throwing away robots we can't use
        # E.g. if the highest per minute ore cost is 4, then there's no point having more than 4 ore robots.
        ore_r = min(state.ore_r, max_ore_cost)
        clay_r = min(state.clay_r, max_clay_cost)
        obs_r = min(state.obsidian_r, max_obsidian_cost)
        
        # optimise state space by throwing away resources we can't possibly spend in the time we have left.
        # E.g. if t=10 and max ore cost is 4, then we can only spend a max of 40 ore.
        # So if we have more than 40, throw it away.
        # Of course, we can't throw away any geodes!
        ore = min(state.ore, state.t_remaining * max_ore_cost - ore_r*(state.t_remaining-1))
        clay = min(state.clay, state.t_remaining * max_clay_cost - clay_r*(state.t_remaining-1))
        obs = min(state.obsidian, state.t_remaining * max_obsidian_cost - obs_r*(state.t_remaining-1))

        # use our optimisations to create the current state
        state = State(state.t_remaining, 
                 ore, clay, obs, state.geode,
                 ore_r, clay_r, obs_r, state.geode_r)

        if state in explored:
            continue
        explored.add(state)
        
        # Now add each possible next state to the frontier...
        # 1st option: Don't make any robots; just accumulate.
        # New mineral levels are simply old levels + number of each robot type
        frontier.append(State(state.t_remaining-1, 
                ore+ore_r, 
                clay+clay_r, 
                obs+obs_r, 
                state.geode+state.geode_r,
                ore_r, clay_r, obs_r, state.geode_r))
        
        # Remaining options: build one of each bot, if we can
        if ore >= blueprint.costs[MineralType.ORE.value].get(MineralType.ORE.value, 0):
            # build ore robot 
            frontier.append(State(state.t_remaining-1,
                    ore-blueprint.costs[MineralType.ORE.value][MineralType.ORE.value]+ore_r, 
                    clay+clay_r, 
                    obs+obs_r, 
                    state.geode+state.geode_r, 
                    ore_r+1, clay_r, obs_r, state.geode_r))
        if ore >= blueprint.costs[MineralType.CLAY.value][MineralType.ORE.value]: 
            # build clay robot
            frontier.append(State(state.t_remaining-1, 
                    ore-blueprint.costs[MineralType.CLAY.value][MineralType.ORE.value]+ore_r, 
                    clay+clay_r, 
                    obs+obs_r, 
                    state.geode+state.geode_r, 
                    ore_r, clay_r+1, obs_r, state.geode_r))
        if (ore >= blueprint.costs[MineralType.OBSIDIAN.value][MineralType.ORE.value] 
                and clay>=blueprint.costs[MineralType.OBSIDIAN.value][MineralType.CLAY.value]): 
            # build obsidian robot
            frontier.append(State(state.t_remaining-1,
                    ore-blueprint.costs[MineralType.OBSIDIAN.value][MineralType.ORE.value]+ore_r, 
                    clay-blueprint.costs[MineralType.OBSIDIAN.value][MineralType.CLAY.value]+clay_r, 
                    obs+obs_r, 
                    state.geode+state.geode_r, 
                    ore_r, clay_r, obs_r+1, state.geode_r))
        if (ore >= blueprint.costs[MineralType.GEODE.value][MineralType.ORE.value] 
                and obs>=blueprint.costs[MineralType.GEODE.value][MineralType.OBSIDIAN.value]): 
             # build geode robot
            frontier.append(State(state.t_remaining-1,
                    ore-blueprint.costs[MineralType.GEODE.value][MineralType.ORE.value]+ore_r, 
                    clay+clay_r, 
                    obs-blueprint.costs[MineralType.GEODE.value][MineralType.OBSIDIAN.value]+obs_r, 
                    state.geode+state.geode_r, 
                    ore_r, clay_r, obs_r, state.geode_r+1))
            
    return best
```

## Part 2

## Results