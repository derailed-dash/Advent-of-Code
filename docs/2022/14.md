---
day: 14
title: Day 14
main_img:
  name: "Stalactites"
  link: /assets/images/stalactites.jpg
tags: 
  - name: classes
    link: /python/classes
  - name: sets
    link: /python/sets
  - name: list comprehension
    link: /python/comprehensions
  - name: map
    link: /python/map-filter-reduce
---

## Page Navigation

- [Problem Intro](#problem-intro)
- [Part 1](#part-1)
- [Part 2](#part-2)
- [Results](#results)

## Problem Intro

We're in some sort of cavern, and we're working within a vertical slice of this cavern.
Within this vertical slice, there are _lines_ of rock which are either horizontal or vertical.

Our input data describes these lines:

```text
498,4 -> 498,6 -> 496,6
503,4 -> 502,4 -> 502,9 -> 494,9
```

Here, each row of input data represents a set of connected lines.
Grains of sand are falling from the ceiling, from point `(500,0)`.
We're told that the sand falls until it comes to rest.  If a grain of sand can move directly down,
diagonally down left, or diagonally down right, it will.

## Part 1

**How many units of sand come to rest before sand starts flowing into the abyss below?**

Here's my strategy:

Soln:
- Use a `Point` dataclass, as I often do!
- Create a `Line` class to represent lines of rock. A line has two points: start and end.
- Create a `Grid` class:
  - It takes all the rock lines as input, and expands them into a `set` of all points tha make up rock.
  - Create an empty `set` to store the positions where sand comes to rest.
  - Create a _filled_ `set` to represent the [union](/python/sets){:target="_blank"} of all points occupied by either rock or sand.
  - Create `drop_sand()` method simulates the falling of a grain of sand.
- For an instance of our `grid` class, drop sand until sand starts falling into the abyss.

So first of all, the `Point` and `Line` classes:

```python
@dataclass(frozen=True)
class Point():
    x: int
    y: int
    
@dataclass(frozen=True)
class Line():
    start: Point
    end: Point
```

They have both been defined as _immutable_ (i.e. unmodifiable) dataclasses. We need them to be immutable,so that we can store them in our `sets` later.

Now the method that reads the input data:

```python
def process_lines(data):
    lines = set()
    for input_line in data:
        point_coords = input_line.split(" -> ")
        points = [Point(*map(int, coord.split(","))) for coord in point_coords]
        for i in range(1, len(points)):
            lines.add(Line(points[i-1], points[i]))
    
    return lines
```

Here I:
- Split each input line at the arrows, to return `x,y` cordinates that make up the successive vertices of a bunch of lines.
- Then use [list comprehension](/python/comprehensions){:target="_blank"} to turn each `x,y` pair into two values, and use [map](/python/map-filter-reduce){:target="_blank"} to turn each value into an `int` representation. From here, we can contruct a `Point` for each point in the input data.
- Finally, iterate through every point from a given input line, and use these points to make `Line` objects. We return all the lines.

Now it's time to construct our `Grid` class:

```python
class Grid():
    SAND_ORIGIN = Point(500,0)
    SAND_VECTORS = [Point(0,1), Point(-1, 1), Point(1, 1)] # down, diagonal left, diagonal right
    
    def __init__(self, lines: set[Line]) -> None:
        self.rock: set[Point] = self._get_rock(lines)
        self.sand = set()
        self.filled = self.rock | self.sand  # union of two sets
        self.min_x = min(point.x for point in self.filled)
        self.max_x = max(point.x for point in self.filled)
        self.min_y = min(point.y for point in self.filled)
        self.max_y = max(point.y for point in self.filled)     
        
    def _get_rock(self, lines: set[Line]):
        """ Process lines of rock. For each point in those lines, add a rock point to the set. """
        rock = set()
        for line in lines:
            x_start = min(line.start.x, line.end.x)
            x_end = max(line.start.x, line.end.x)
            y_start = min(line.start.y, line.end.y)
            y_end = max(line.start.y, line.end.y)
            rock.update({Point(x,y) for x in range(x_start, x_end+1)
                                    for y in range(y_start, y_end+1)})
        
        return rock
    
    def _is_empty(self, point: Point) -> bool:
        """ If this point is not rock or sand, return True. """
        if point not in self.filled:
            return True
        
        return False
    
    def drop_sand(self) -> Point:
        """ Sand falls down until it reaches an obstacle.
        If it reaches an obstacle, it will they try to fall diagonally left, then diagonally right. """
        grain = Grid.SAND_ORIGIN
        falling = True
        while falling:
            for v in Grid.SAND_VECTORS:
                candidate = Point(grain.x + v.x, grain.y + v.y)
                if self._is_empty(candidate):
                    if candidate.x < self.min_x or candidate.x > self.max_x: # we've reached fall-through
                        return None
                    
                    grain = candidate
                    self.min_y = min(self.min_y, grain.y)

                    break  # move out of the vectors loop
            else: # Get here if all our fall positions are full
                falling = False

        self._add_sand(grain)           
        
        return grain

    def _add_sand(self, grain):
        self.sand.add(grain)
        self.filled.add(grain)
    
    def __str__(self) -> str:
        rows = []
        for y in range(self.min_y, self.max_y+1):
            row = f"{y:3d} "
            
            # print 1 col to either side
            for x in range(self.min_x-1, self.max_x+2):
                point = Point(x,y)
                if point in self.rock:
                    row += "#"
                    continue
                if point in self.sand:
                    row += "o"
                    continue
                row += "."
            
            rows.append(row)
            
        return "\n".join(rows)
```

How this works:

- The `drop_sand()` method:
    - Drops sand grain from the top.
    - Sand grain falls according to rules, specified as three vectors: down, down-left, down-right.
    - Iterate through vectors. The next candidate point (i.e. where the same might fall) is given by the current sand grain point, plus the vector.
    - If candidate point is empty, the sand can fall to it.  If not, sand has stopped falling.
    - Keep iterating until sand starts falling into the abyss.
    - If sand has come to rest, return the grain point. If not, then return None.
- Back in `main()`, call `drop_sand()` until no more grains are returned (i.e. at rest). 
  Then count `grid.sand`.

## Part 2

## Results