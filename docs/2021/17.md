---
day: 17
title: Day 17
problem: Trick Shot
main_img:
  name: Gorillas
  link: /assets/images/gorillas.png
tags: 
  - name: Regular expressions
    link: https://docs.python.org/3/howto/regex.html
  - name: Matplotlib
    link: https://matplotlib.org/
  - name: dataclass
  - name: splat
---
## Solution Intro

They say `HI`?  The stupid elves say `HI`?  The next elf I see is getting punched in the face.

Anyhoo... Today's challenge is a bit of a relief compared to yesterday.

We need to fire a probe into a large ocean trench. We're firing probes from initial `x,y` position of 0,0, and we need the probes to pass through a target area. We're able to adjust the initial x,y velocity of our probe.  We're told that:

- `x` is the forward (horizontal) velocity.
- `y` is the upward (vertical) velocity.  Positive means up.
- For any given velocity `x,y`, the probe will move a horizontal distance `x` and a vertical distance `y`, per _step_.  I like to think of a step as a unit of time, `t`.
- `x` decreases by 1 _towards 0_, with each step, due to drag.  This means that regardless of our initial value of `x`, there will come a point where our probe will cease to move horizontally.
- `y` _always_ decreases by 1, due to gravity. Thus, regardless of our initial value of `y`, `y` will always approach negative infinity.
- Combining these two facts, we know that eventually, every probe will fall straight down.

Our input is a target area, and it looks like this:

```
target area: x=20..30, y=-10..-5
```

The `x` and `y` values represent ranges.  Thus, the target area is a rectangle.

We could draw the rectangle like this, showing our `x,y` coordinates at each corner:

```
20, -5 xxxxxxxxxxx 30, -5
       xxxxxxxxxxx
       xxxxxxxxxxx
       xxxxxxxxxxx
       xxxxxxxxxxx
20,-10 xxxxxxxxxxx 30,-10
```

Crucially, we're told that for our probe to successfully make it to the trench, it needs to hit the target area _after any step_. Thus, for any given time `t`, the probe's location must in _in the target area_.  It is not sufficient to determine that the probe simply passed through the target area between any time t and any time t-1.

## Part 1

**What is the highest y position it reaches on this trajectory?**

Okay, this is simple enough.  Essentially, we need to lob the probe up in an arc. We're looking for the arc that hits the target area, and reaches the highest point. Okay, it might not be an _actual arc_, since our horizontal movement might stop whilst it's still going up. I.e. it might still be going _up_, whilst not moving _out_.  And that won't look much like an arc!

Here's the game plan:

- Establish our target area, with corners _top_left_, _top_right_, _bottom_right_, _bottom_left_. 
- Create a formula to calculate velocity at step t, given an initial velocity.
- Then, loop through a range of initial velocities, with:
  - x from 0 to x_right, since we can only fire right, towards the target.
  - y from bottom_y to abs(bottom_y), since we can fire both down towards the target, but also up.
  - Then loop infinitely through steps, and determine x,y locations at each step.
    - Store max y achieved in this loop so far.
    - Build a dict of {init vel: max y} for any init velocities that hit the target.
  - Return the max y overall.

### Setup

```python
from dataclasses import dataclass
import logging
from pathlib import Path
import time
import re
from matplotlib import pyplot as plt

logging.basicConfig(format="%(asctime)s.%(msecs)03d:%(levelname)s:%(name)s:\t%(message)s", 
                    datefmt='%Y-%m-%d %H:%M:%S')
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

SCRIPT_DIR = Path(__file__).parent
# INPUT_FILE = "input/input.txt"
INPUT_FILE = "input/sample_input.txt"

RENDER = True
OUTPUT_DIR = Path(SCRIPT_DIR, "output/")
OUTPUT_FILE = Path(OUTPUT_DIR, "trajectory.png")
```

- I've included `matplotlib`, as I want to visually plot the trajectories. (You don't have to, obviously!)
- I've included `re`, as I'm going to parse the input data with regular expressions.

### Solution

First, some simple classes:

```python
@dataclass(frozen=True)
class Point():
    x: int
    y: int

class Velocity(Point):
    """ A vector represented as (x, y) values """
    
@dataclass
class Rect():
    """ Rectangle from four corner Points, and knows whether a given point is enclosed by this rectangle """
    left_x: int
    right_x: int
    bottom_y: int
    top_y: int

    def encloses(self, point:Point) -> bool:
        return (self.left_x <= point.x <= self.right_x 
                and self.bottom_y <= point.y <= self.top_y)
        
    def as_polygon(self) -> tuple[list, list]:
        """ Convert to set of polygon points, in the order tl, tr, br, bl, 
        and returned as (list of x coords, list of y coords) """
        return ([self.left_x, self.right_x, self.right_x, self.left_x],
                [self.top_y, self.top_y, self.bottom_y, self.bottom_y])
```

Notes on these:

- `Point` is simple enough. It's an immutable dataclass.
- `Velocity` subclasses `Point`.  In fact, our `Velocity` class is identical to `Point`.  But I think it's conceptually easier to be able to work with both points, and velocities.  But at the end of the day, both classes simple have x and y values.
- `Rect` represents a rectangle, as four corner points. 
  - The `encloses()` method is what we'll use to check whether a probe is in the target area (rectangle).
  - The `as_polygon()` method returns our four corners as a clockwise list of all the corner x values (starting top left), and a clockwise list of all the corner y values (also starting top left). I use this when I'm rendering the rectangle in matplotlib.

Now our function to determine the velocity at any time, given an initial velocity:

```python
def velocity_at_step(init: Velocity, t: int) -> Velocity:
    """ Returns the velocity (x,y) at a given step. """
    x = abs(init.x) - t if t < init.x else 0  # shrinks towards 0
    y = init.y - t  # always decreases towards -ve infinity
    
    return Velocity(x, y)
```

Now let's read the data.

```python
input_file = Path(SCRIPT_DIR, INPUT_FILE)
with open(input_file, mode="rt") as f:
    data = f.read().strip()

# Note that x and y values can be -ve
match = re.search(r"x=(-?\d+)\.\.(-?\d+), y=(-?\d+)\.\.(-?\d+)", data)
assert match, "Don't expect invalid input data"
target = Rect(*map(int, match.groups()))
logger.info(target)
```

And now let's try some trajectories!

```python
successful_peaks = {}    # init_velocity: peak
highest_trajectory = []
max_y = 0
for x in range(1, target.right_x+1):   # No point having x larger than max target distance
    for y in range(target.bottom_y, abs(target.bottom_y)):   # remember we can fire up
        init_v = Velocity(x, y)
        hit, trajectory = evaluate_trajectory(target, init_v)
        if hit:     # if this was a good trajectory to hit the target
            this_max_y = max(point.y for point in trajectory) 
            successful_peaks[init_v] = this_max_y  # store the heighest point for this init_v               
            if this_max_y > max_y:  # If this trajectory has given a new highest point
                highest_trajectory = trajectory
                max_y = this_max_y             

logger.info("Max peak=%d", max_y)
```

// todo

And now let's examine `evaluate_trajectory()`:

```python

```

## Part 2
