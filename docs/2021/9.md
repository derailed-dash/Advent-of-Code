---
day: 9
title: Day 9
problem: Smoke Basin
main_img:
  name: Lava tubes 
  link: /assets/images/lava-basin.jpg
tags: 
  - name: deque
  - name: dataclass
  - name: Breadth First Search (BFS)
    link: https://www.redblobgames.com/pathfinding/a-star/introduction.html
  - name: Flood fill
    link: https://en.wikipedia.org/wiki/Flood_fill
  - name: functools reduce
    link: https://www.geeksforgeeks.org/reduce-in-python/
  - name: annotations
  - name: orthogonal
    link: https://en.wikipedia.org/wiki/Orthogonality
---
## Solution Intro

This is a fairly straightforward problem, and an example of where we need to do a `flood fill`. It's the first challenge in this year's AoC that lends itself to a [Breadth First Search (BFS)](https://www.redblobgames.com/pathfinding/a-star/introduction.html){:target="_blank"}. This is an _extremely_ useful algorithm that comes in handy for a lot of BFS problems.  It's really worth understanding it!

We're told we're navigating underwater lava tubes.  Hot smoke fills the caves and drifts to the floor. Our input is a heightmap, which looks like this:

```
2199943210
3987894921
9856789892
8767896789
9899965678
```
This is a 2D representation of the floor, which each digit being the height at that location.  

### Setup

```python
import logging
import os
import time
from __future__ import annotations
from collections import deque
from dataclasses import dataclass
from functools import reduce
```

### Part 1

Our goal is to find the sum of the risk of all the low points, where:

- a low point is a point where all adjacent points are higher
- Risk level is given by `n+1`, where `n` is the height at that position.

I'll start by creating a couple of useful classes. First, we'll create a `Point` class, which is a dataclass.  (We've used dataclasses [before]({{"/2021/5" | relative_url }}){:target="_blank"} in this AoC.)

```python
@dataclass(frozen=True)
class Point():
    ADJACENT_DELTAS = [(dx,dy) for dx in range(-1, 2) 
                               for dy in range(-1, 2) if abs(dy) != abs(dx)]
    
    x: int
    y: int
    
    def yield_neighbours(self) -> Iterator[Point]:
        """ Yield adjacent (orthogonal) neighbour points """
        for vector in Point.ADJACENT_DELTAS:
            yield Point(self.x + vector[0], self.y + vector[1])        
```

This `Point dataclass` has `frozen=True`, which makes it _immutuble_.  The `Point` class stores its x and y positions, and knows how to yield every adjacent (orthogonal) location. It does this by storing the vectors (dx, dy) to get from any `Point` to all adjacent `Points`.  This list of delta vectors is created using a _multi-sequence comprehension_. I.e. a `list comprehension` that generates a single one-level `list` using nested `for` loops. By only returning dx,dy deltas where `abs(dy) != abs(dx)` we are excluding both diagonal deltas, as well as the delta 0,0. In short, it gives us this:

```
[(-1, 0), (0, -1), (0, 1), (1, 0)]
```

Now we'll create a class that represents the input data `Grid`. It stores the `list[list[int]]` passed to the Grid constructor.  It then determines the width (length of the first row) and height (number of rows) of the `list`.

A note on the methods:

- `height_at_point(self, point)` returns the value (height) for any `Point` passed to the method.
- `risk_at_point(self, point)` returns the risk for any `Point` passed to it, i.e. the height+1.
- `low_points()` creates a `set` to store all low points.  Then it iterates through every location in the grid, creates a `Point` at that location, and then calls `is_low_point(point)` for that `Point`.
- Finally, `is_low_point(point)` checks the value at the `Point` and the value of all adjacent `Points` (that are part of the grid), and returns `True` only if the value for this `Point` is lower than that of all the adjacent `Points`.

```python
class Grid():
    def __init__(self, grid_array: list) -> None:
        self._array = grid_array
        self._width = len(self._array[0])
        self._height = len(self._array)
        
    def height_at_point(self, point: Point) -> int:
        """ Height is given by the value at this point """
        return self._array[point.y][point.x]
    
    def risk_at_point(self, point: Point) -> int:
        """ Risk is given by height at point + 1 """
        return self.height_at_point(point) + 1
    
    def low_points(self) -> set:
        """ Returns all low points in the grid """
        low_points = set()
        
        for y in range(self._height):
            for x in range(self._width):
                point = Point(x, y)
                if self.is_low_point(point):
                    low_points.add(point)
                    
        return low_points
    
    def is_low_point(self, point: Point) -> bool:
        """ Determines if this point is a low point, i.e. surrounded by higher values. """
        value = self.height_at_point(point)
        
        for neighbour in point.yield_neighbours():
            if self.valid_location(neighbour):
                if self.height_at_point(neighbour) <= value:
                    return False
                
        return True
                   
    def valid_location(self, point: Point) -> bool:
        """ Check if a location is within the grid """
        if (0 <= point.x < self._width and 0 <= point.y < self._height):
            return True
        
        return False
```

```python
input_file = os.path.join(SCRIPT_DIR, INPUT_FILE)
with open(input_file, mode="rt") as f:
    data = [[int(posn) for posn in row] for row in f.read().splitlines()]
    
grid = Grid(data)
low_points = grid.low_points()
risk_by_point = {point: grid.risk_at_point(point) for point in low_points}
logger.info("Part 1: low_point_risks = %d", sum(risk_by_point.values()))
```
### Part 2

