---
day: 22
title: Day 22
main_img:
  name: Splitting Time
  link: /assets/images/abstract-cubes.jpg
tags: 
  - name: Regular expressions
    link: https://docs.python.org/3/howto/regex.html
---
## Solution Intro

Okay, we're going to play a game of **Dirac Dice**. Part 1 was nice and easy.  Part 2 nearly broke my brain.

We're told:

- Players start with a score of 0.
- Each player starts on a random space. The starting space does not contribute to the initial player score.
- Players take turns. On a player's turn, the player rolls the die 3 times.
- The sum of the die rolls is the number of spaces they move, clockwise.  Whatever space they land on, that is the score they are awarded for that turn.  This is added to their existing score.

## Part 1

We're given a _100 sided deterministic die_.  I.e. every roll of the die returns an incrementing number from `1` to `100`.  When it gets to `100`, we go back to `1`.  The game is won when a player reaches a score of at least 1000.

**What is the product of the score of the losing player and the number of times the die was rolled in the game?**

This is quite an easy problem, and we get to play with a few new things.

### Setup

Some new things here, which we'll cover as we get to them.

```python
from abc import ABC, abstractmethod
from functools import lru_cache
import logging
import os
import time
from typing import Iterator, NamedTuple
from copy import deepcopy
from itertools import product

SCRIPT_DIR = os.path.dirname(__file__) 
INPUT_FILE = "input/input.txt"
# INPUT_FILE = "input/sample_input.txt"

logging.basicConfig(format="%(asctime)s.%(msecs)03d:%(levelname)s:%(name)s:\t%(message)s", 
                    datefmt='%H:%M:%S')
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
```

### Solution

First, a class for the players:

This subclasses `NamedTuple`.  It's a lot like the more powerful `Dataclass`. It allows us to create a class which is actually a `tuple`, but where the attributes of the `tuple` can be referenced by name.

Now we'll create an _abstract_ class, called `AbstractDie`:

The concept of an _abstract_ class is that it provides some functionality that we can reuse in subclasses, but the abstract class itself _cannot be instantiated_. This is because the _abstract_ class has one or more _abstract methods_, meaning that these methods do not yet have any actual implementation. So when we extend the abstract class, we need to provide an implementation for any _abstract methods_. In our `AbstractDie`, we can see that the `_roll()` method lacks any implementation, and is decorated as `@abstractmethod`.

Note that our `AbstractDie` class in inherits from `ABC`, i.e. the _abstract base class_.  This is what marks our class as _abstract_.

After initialisation, the game is played by calling `play()` on our `Game` instance.

- We alternate between our two players, i.e. with the current player passed to `_take_turn()`.
- Taking a turn results in the player landing on a new space, which returns a new cumulative score.  
- If the score exceeds the target (i.e. 1000), then the game ends. The winning player number is returned.

The `_take_turn()` method:

- Gets the current player position and score.
- Performs our three die rolls, and then gets the `sum` of those rolls.
- Determines the new position, by moving forward the number of spaces given the sum of the die rolls.
- Updates the player's score, based on that new position.

Finally, we run it:

```python
    input_file = os.path.join(SCRIPT_DIR, INPUT_FILE)
    with open(input_file, mode="rt") as f:
        data = f.read().splitlines()

    init_players: list[Player] = []
    for line in data:
        tokens = line.split() # Into 5 tokens, e.g. "Player" "1" "starting" "position:" "4"
        init_players.append(Player(posn=int(tokens[-1]), score=0))
    
    # Part 1
    players = deepcopy(init_players)
    die = DeterministicDie(faces=100)
    game = Game(players, die, target=1000)
    won = game.play()
    
    total_rolls = game.die.total_rolls
    logger.info("Die has been rolled %d times", total_rolls)
    logger.info("Player %d won with score of: %d", won+1, players[won].score)
    logger.info("Part 1 result = %d\n", total_rolls * min(player.score for player in game.players))
```

This is what we're doing here:

- Start by parsing the input `str` to get starting positions.  We create `Player` objects from these starting positions. We set their scores to 0.
- We then create a 100-sided `DeterministicDie`.
- We then create a new `Game` instance, passing in our players, the `DeterministicDie`, and the target score of 1000.
- Finally, we run `game.play()`.
- We can get the total number of die rolls from `game.die.total_rolls`.  I.e. `die` is a `property` of our `Game` class, and `total_rolls` is a property of our `DeterministicDie`.
- We can get the score of the losing player, by getting the `min()` `player.score` of all the players in the game.  (Of course, there are only two.)

So, Part 1 was pretty easy!

## Part 2

Well, this escalated quickly!

We now only have a 3-sided die.  It's just as well.  It's a _quantum die_. Every roll of the die splits the universe into three different universes: one for each of the possible roll outcomes!

To win, we only need to reach a score of 21.

Our objective:

**Find the player that wins in more universes; in how many universes does that player win?**

OMG.
