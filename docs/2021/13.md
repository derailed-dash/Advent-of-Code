---
day: 13
title: Day 13
problem: Transparent Origami
main_img:
  name: Cave network
  link: /assets/images/caves.jpg
tags: 
  - name: Breadth First Search (BFS)
    link: https://www.redblobgames.com/pathfinding/a-star/introduction.html
  - name: adjacency dictionary
  - name: pathlib
    link: https://medium.com/@ageitgey/python-3-quick-tip-the-easy-way-to-deal-with-file-paths-on-windows-mac-and-linux-11a072b58d5f
  - name: graphs
    link: https://en.wikipedia.org/wiki/Graph_(abstract_data_type)
  - name: networkx
    link: https://networkx.org/documentation/stable/index.html
  - name: matplotlib
    link: https://matplotlib.org/
  - name: visualisation
  - name: hashable
---

## Solution Intro

Phew. Back to something a bit quicker to solve. Take a moment to appreciate this challenge. After this one, you wont see me using the word _trivial_ again!!

We want to activate the sub's thermal imaging system.  But to activate it, we need a code from the instruction manual. (Anyone else nostalgic for 90s copy protection?) In the manual is a transparent sheet with random dots, and a set of instructions on how to fold the paper.

The imput looks like this:

```
6,10
0,14
9,10
0,3
10,4
4,11
...
fold along y=7
fold along x=5
```

- The number pairs are the x,y coordinates of each dot on the paper; where 0,0 is the top.
- We're told that dots will never appear on a fold line.
- When we fold, we'll find that many dots from each side of the fold line will be overlapping.

## Part 1

We're asked how many dots are visible, after performing the first fold instruction. (Remember that some dots will overlap.)

### Setup

Nothing new here:

```python
import logging
import os
import time
from collections import defaultdict, deque

logging.basicConfig(format="%(asctime)s.%(msecs)03d:%(levelname)s:%(name)s:\t%(message)s", 
                    datefmt='%H:%M:%S')
logger = logging.getLogger(__name__)
logger.setLevel(level=logging.INFO)

SCRIPT_DIR = os.path.dirname(__file__) 
INPUT_FILE = "input/input.txt"
# INPUT_FILE = "input/sample_input.txt"
```

### The solution

Now we need to build a **graph**.  In computing (and maths), a graph is a finite set of _vertices_ (aka _nodes_ or _points_), which are connected by _edges_ (aka _links_).

We start by creating our `CaveGraph` class:

```python
class CaveGraph():
    """ Stores pairs of connected caves, i.e. edges. 
    Determines all caves from supplied edges. 
    Determines which caves are small, and which are large. 
    Creates a lookup to obtain all caves linked to a given cave. 
    Finally, knows how to determine all unique paths from start to end, 
    according to the rules given. """
    
    START = "start"
    END = "end"
    
    def __init__(self, edges:set[tuple[str, str]]) -> None:
        """ Takes a set of edges, where each edge is in the form (a, b) """
        self.start = CaveGraph.START
        self.end = CaveGraph.END

        self._edges: set[tuple[str, str]] = set(edges)
        self._nodes: set[str] = set()
        self._small_caves: set[str] = set()
        self._large_caves: set[str] = set()
        self._determine_caves()  # populate the empty fields
        
        # Create lookup (adjacency) dict to find all linked nodes for a node
        self._node_map: dict[str, set[str]] = defaultdict(set)
        for x,y in edges:      # E.g. x, y
            self._node_map[x].add(y)
            self._node_map[y].add(x)
            
        assert self.start in self._node_map, "Start needs to be mapped"
        assert self.end in self._node_map, "Finish needs to be mapped"
    
    @property
    def edges(self):
        """ All the edges.  An edge is one cave linked to another. """
        return self._edges
    
    @property
    def small_caves(self):
        """ Caves labelled lowercase. Subset of self.caves. """
        return self._small_caves    

    @property
    def large_caves(self):
        """ Caves labelled uppercase. Subset of self.caves. """        
        return self._large_caves

    def _determine_caves(self):
        """ Build a set of all caves from the edges.
        This will also initialise small_caves and large_caves """
        for edge in self._edges:
            for cave in edge:
                self._nodes.add(cave)
                if cave not in (self.start, self.end):
                    if cave.islower():
                        self._small_caves.add(cave)
                    else: 
                        self._large_caves.add(cave)

    def _get_adjacent_caves(self, node: str) -> set[str]:
        """ Returns the adjacent caves, given a cave input. """
        return self._node_map[node]
```

Things to say about this:

- First, the `__init__()` method:
  - We can see it expects to be initialised using a `set` of pairs of locations. I.e. a set of _edges_, where each edge is in the form of two _nodes_ (which are caves).
  - It stores all the edges as `_edges`.
  - It then runs `_determine_caves()`, which:
    - Iterates through all the edges.
    - For each edge, looks at each cave in the pair.
    - Adds the edge (the cave) to `_caves`. We're using sets, which only store unique values.  So if we add the same cave more than once, it doesn't matter.
    - Checks if the cave is small or large, and adds to `_small_caves` and `_large_caves`, respectively.
    - Note how we're once again prefixing all class variables and methods with `_`, where they are only intended to be used by the object, and are not intended to be accessed outside the object.

We run it like this:

```python
input_file = os.path.join(SCRIPT_DIR, INPUT_FILE)
with open(input_file, mode="rt") as f:
    edges = set(tuple(line.split("-")) for line in f.read().splitlines())
    
graph = CaveGraph(edges)    # Create graph from edges supplied in input

# Part 1
unique_paths = graph.get_paths_through()
logger.info("Part 1: unique paths count=%d", len(unique_paths))
```

## Part 2

Now we're told we're allowed to visit any single small cave twice for any given path.  Implementing this requires some thinking!!

```python
    def get_paths_through(self, small_cave_twice=False) -> set[tuple]:
        """ Get all unique paths through from start to end, using a BFS

        Args:
            small_cave_twice (bool, optional): Whether we can 
                    visit a small cave more than once. Defaults to False.
        """
        start = (self.start, [self.start], False)  # (starting cave, [path with only start], used twice)
        queue = deque()
        queue.append(start)  

        unique_paths: set[tuple] = set()    # To store each path that goes from start to end
        
        while queue:
            # If we popleft(), we do a BFS.  If we simply pop(), we're doing a DFS.
            # Since we need to discover all paths, it makes no difference to performance.
            cave, path, used_twice = queue.popleft()    # current cave, paths visited, twice?
            
            if cave == self.end:    # we've reached the end of a desired path
                unique_paths.add(tuple(path))
                continue
            
            for neighbour in self._get_adjacent_caves(cave):
                new_path = path + [neighbour]   # Need a new path object
                if neighbour in path:
                    # big caves fall through and can be re-added to the path
                    
                    if neighbour in (self.start, self.end):
                        continue # we can't revisit start and finish
                    
                    if neighbour in self.small_caves:
                        if small_cave_twice and not used_twice:
                            # If we've visited this small cave once before
                            # Then add it again, but "use up" our used_twice
                            queue.append((neighbour, new_path, True))
                        continue
                
                    assert neighbour in self.large_caves
                    
                # If we're here, it's either big caves or neighbours not in the path
                queue.append((neighbour, new_path, used_twice))
                logger.debug(new_path)
                
        return unique_paths
```

And to run it:

```python
# Part 2
unique_paths = graph.get_paths_through(small_cave_twice=True)
logger.info("Part 2: unique paths count=%d", len(unique_paths))
```

The output for both parts looks like this:

```
09:41:30.114:INFO:__main__:     Part 1: unique paths count=5228
09:41:30.801:INFO:__main__:     Part 2: unique paths count=131228
09:41:30.817:INFO:__main__:     Execution time: 0.7296 seconds
```

## Visualisation

Now let's use **NetworkX**, in combination with **Matplotlib**, to render the output as an **image**.

Just add this to our `CaveGraph` class:

```python
    def render(self, file):
        _ = plt.subplot(121)
        pos = nx.spring_layout(self._graph)
        
        # set colours for each node in the array, in the same order as the nodes
        colours = []
        for node in self.nodes:
            if node in (CaveGraph.START, CaveGraph.END):
                colours.append("green")
            elif node in self.large_caves:
                colours.append("blue")
            else:
                colours.append("red")
        
        nx.draw(self._graph, pos=pos, node_color=colours, with_labels=True)
        
        dir_path = Path(file).parent
        if not Path.exists(dir_path):
            Path.mkdir(dir_path)
        plt.savefig(file)
```

This code:

- Defines a Pyplot plot area
- Uses NetworkX's built in `spring_layout()` method to create a set of node positions to be rendered, saved as `pos`.
- We then create a `list` of `colours`, with the same number of items as `pos`.  We use this to colour the nodes, based on their type, e.g. start/end, small cave, and big cave.
- We then render the plot, using `nx.draw()`, passing in the graph, the positions, the colours, and turning on labels.
- Finally, we save the rendering as a file, creating the path if it doesn't exist.

We call it like this:

```python
if RENDER:
    graph.render(OUTPUT_FILE)
```

I'm saving the file as a .ping.  I've used the `RENDER` constant so that I can easily turn rendering on and off.

The rendered graph looks like this for the sample data:

![Cave graph sample data]({{"/assets/images/cave_graph_sample_data.png" | relative_url }})
