---
day: 24
title: Day 24
main_img:
  name: ALU
  link: /assets/images/arithmetic-and-logic-unit.png
tags: 
  - name: introspection
    link: https://www.geeksforgeeks.org/code-introspection-in-python/
  - name: tqdm
  - name: progress bar
---
<script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
## Solution Intro

_Oh, this one looks easy enough._  **Wrong!** \
_I just need to write an ALU simulator that knows how to process some instructions._ **Wrong!**

## Overview

We're told that the sub runs off an _arithmetic logic unit_ that takes four integer variables (`w`, `x`, `y`, and `z`), and is capable of performing dix different instructions with these variables.

The ALU processes programs, which are sets of instructions.  The instructions are procesed in order, from beginning to end.

We're given a few sample input programs. Like this one:

```text
inp w
add z w
mod z 2
div w 2
add y w
mod y 2
div w 2
add x w
mod x 2
div w 2
mod w 2
```

We're told we need to use our ALU to validate the sum's _model number_.  We're given a program called _MONAD_ which takes any 14-digit number (where the digits must be 1 to 9, inclusive), and processes the number.  My actual MONAD data, for example, 14 `inp w` instructions.

We're told a given _model number_ is only valid if, after processing all the instructions in the MONAD program, variable `z` is set to 0.

## Part 1

**What is the largest model number accepted by MONAD?**

So the goal is to find the largest possible 14-digit number which results in a `z` value of 0, after running the number through our program.

### The ALU Simulator 

Having done a few AOCs before, I jumped straight to writing an ALU simulator. _(Spoiler alert: this was a mistake!)_

```python
class ALU():
    """ Simulate processor with four registers and six instructions """
    def __init__(self) -> None:
        self._vars = {'w': 0, 'x': 0, 'y': 0, 'z': 0}
        
        self._input = None
        self._input_posn = 0
        
        self._instructions: list[tuple[str, list[str]]] = []     # list of instructions in the format [instr, [parms]]
        self._ip = 0
        
    @property
    def vars(self):
        return self._vars
    
    def _set_input(self, value: str):
        """ Take a number and store as a str representation """
        assert value.isdigit, "Must be number"
        assert len(value) == 14, "Must be 14 digit input"
        self._input = value
        self._input_posn = 0        
     
    def _set_var(self, var, value):
        """ Sets the specified var to the specified value. """
        if var not in self._vars:
            raise KeyError(f"No such var '{var}'")
        
        self._vars[var] = value
    
    def _reset(self):
        for var in self._vars:
            self._vars[var] = 0

        self._input = None
        self._input_posn = 0
        self._ip = 0
        
    def run_program(self, input_str):
        """ Process instructions in the program.
            - Converts the program input to a list of instructions and stores them in the computer.
            - Then executes the instructions one at a time.

        Args:
            instructions (list): Each instr is in the format ["instr params"], e.g. div z 1
        """
        self._reset()      
        self._set_input(input_str)
        
        for instruction in self._instructions:
            self._execute_instruction(instruction)
            self._ip += 1

    def set_program(self, instructions_input):
        """ Create a list of instructions, 
        where each instruction is of the format: (str, list[str]) """
        self._instructions = []
        
        for line in instructions_input:
            instr_parts = line.split()
            instr = instr_parts[0]
            instr_parms = instr_parts[1:]
        
            self._instructions.append((instr, instr_parms))
        
    def _execute_instruction(self, instruction:tuple[str, list[str]]):
        """ Takes an instruction, and calls the appropriate implementation method.

        Args:
            instr_and_parms (list): The instruction, in the format (instr, [parms])
            
        Raises:
            AttributeError if instruction is not understood
        """
        # logger.debug("Instruction: %s", instruction)
        instr = instruction[0]
        instr_parms = instruction[1]
        
        # call the appropriate instruction method
        try:
            self.__getattribute__(f"_op_{instr}")(instr_parms)          
        except AttributeError as err:
            raise AttributeError(f"Bad instruction {instr} at {self._ip}") from err

    def int_or_reg_val(self, x) -> int:
        """ Determine if the variable is an int value, or the value in a register """
        if x in self._vars:
            return self._vars[x]
        else:
            return int(x)
        
    def _op_inp(self, parms:list[str]):
        var = parms[0]
        assert self._input, "Input value not set"
        assert self._input_posn < len(self._input), "Too many input digits!"
        # logger.debug("Reading input: %s into %s", self._input[self._input_posn], var)
        input_digit = int(self._input[self._input_posn])
        self._vars[var] = input_digit
        self._input_posn += 1
    
    def _op_add(self, parms:list[str]):
        """ Add a to b and store in a. Param b could be a var or a number. """
        self._vars[parms[0]] += self.int_or_reg_val(parms[1])
    
    def _op_mul(self, parms:list[str]):
        """ Multiply a by b and store in a. Param b could be a var or a number. """
        self._vars[parms[0]] *= self.int_or_reg_val(parms[1])
    
    def _op_div(self, parms:list[str]):
        """ Divide a by b and store in a. Param b could be a var or a number. """
        parm_b = self.int_or_reg_val(parms[1])
        assert parm_b != 0, "Integer division by 0 is bad."
        self._vars[parms[0]] //= parm_b
        
    def _op_mod(self, parms:list[str]):
        """ Modulo a by b and store in a. Param b could be a var or a number. """
        parm_a = self._vars[parms[0]]
        parm_b = self.int_or_reg_val(parms[1])
        try:
            assert parm_a >= 0 and parm_b != 0, "Integer division by 0 is bad." 
            self._vars[parms[0]] %= parm_b     
        except AssertionError as err:
            raise AttributeError(f"Bad instruction: {parm_a} mod {parm_b}") from err

    def _op_eql(self, parms:list[str]):
        """ Chec if a and b are equal. Store 1 if equal. Param b could be a var or a number. """
        self._vars[parms[0]] = 1 if self._vars[parms[0]] == self.int_or_reg_val(parms[1]) else 0
                 
    def __repr__(self):
        return f"{self.__class__.__name__}{self._vars}"  
```

So what does this do?

- When we create an `ALU` object, we initialise our four variables to 0, in dict.
- We maintain an index pointer - `_input_posn` - that points to the position of the current digit being processed, in our 14-digit number.  Recall that we act on one digit at a time from this number, every time we see an `inp` instruction.
- We also maintain an instruction pointer - `_ip` - that points to the current instruction being processed in the program.
- We have a convenience property, `vars` to allow an external program to read the current value of any of the variables.
- We define the program that the ALU will run, by running `set_program()`, passing in a list of of instructions. This takes each instruction line, and converts each to an instruction part (`instr`), and a parameters part (`instr_parms`).
- We run the input program using the `run_program()` method, which expects the 14 digit value as input. It then iterates through all instruction pairs, running `_execute_instruction()` for each.
  - Within the `_execute_instruction()`, we now do a bit of **introspection**.  This is where we use Python to examine its own objects at run time, in order to determine information about those objects.  Specifically, we're using the `__getattribute__()` method, and passing in a `str`, in order to identify any attribute (or method) that matches the `str` passed in.
  - We've created a number of _methods_ in the `ALU` class, such as `_op_inp()`, `op_add()`, `op_mul()`.  So, when we do something like `self.__getattribute__(f"_op_{instr}")`, passing in the `instr` type from the current instruction, Python actually returns the _method_ with that name, and runs it!!  Thus, this is a clever way to map a bunch of method names to a bunch of instructions.

Great!  So now all we have to do is create the `ALU`, initialise the program to our set of instructions, and then run it with every possible 14 digit number that doesn't contain a 0.  We could do something like this:

```python
input_file = os.path.join(SCRIPT_DIR, INPUT_FILE)
with open(input_file, mode="rt") as f:
    data = f.read().splitlines()

alu = ALU()
alu.set_program(data)
for int_val in tqdm(range(99999999999999, 11111111111110, -1)):
    val = str(int_val)
    if '0' in val:
        continue
    
    alu.run_program(val)
    if alu.vars['z'] == 0:
        logger.info("%s verified.", val) 
```

As I've done with an earlier program, I've wrapped my `for` loop with `tqdm`, in order to give me a progress bar for this long running loop.  Usefully, the progress bar includes an estimated completion time. So yeah... **It's going to take about 200 years.**  _We're going to need a bigger boat._  Or a better solution.

**TIME TO THROW ALL THAT AWAY!**

So, what have we learned?  We've learned that running each instruction in MONAD is going to take too long. So instead...

**Maybe we need to determine what MONAD is actually trying to do, and come up with a more efficient way to do that?**

### Understanding what MONAD Does

When I examine my MONAD input, it turns out that the program is made up of 14 repeating blocks of 18 nearly identical lines. Here I'm showing the first 5 repeats, side by side...

<style>
  grn { color: #66FF00; }
  red { color: red } 
  mag { color: magenta }
  yellow { color: yellow } 
  cyan { color: cyan }
</style>
<pre class="language-plaintext highlighter-rouge highlight">
     1          2          3          4          5
     --------   --------   --------   --------   -------- 
 1   inp w      inp w      inp w      inp w      inp w
 2   mul x 0    mul x 0    mul x 0    mul x 0    mul x 0
 3   add x z    add x z    add x z    add x z    add x z
 4   mod x 26   mod x 26   mod x 26   mod x 26   mod x 26
 5   <red>div z 1    div z 1    div z 1    div z 1    div z 26</red>   
 6   <mag>add x 12   add x 12   add x 13   add x 12   add x -3</mag>
 7   eql x w    eql x w    eql x w    eql x w    eql x w
 8   eql x 0    eql x 0    eql x 0    eql x 0    eql x 0
 9   mul y 0    mul y 0    mul y 0    mul y 0    mul y 0
10   add y 25   add y 25   add y 25   add y 25   add y 25
11   mul y x    mul y x    mul y x    mul y x    mul y x
12   add y 1    add y 1    add y 1    add y 1    add y 1
13   mul z y    mul z y    mul z y    mul z y    mul z y
14   mul y 0    mul y 0    mul y 0    mul y 0    mul y 0
15   add y w    add y w    add y w    add y w    add y w
16   <yellow>add y 7    add y 8    add y 2    add y 11   add y 6</yellow>
17   mul y x    mul y x    mul y x    mul y x    mul y x
18   add z y    add z y    add z y    add z y    add z y
</pre>

Here's what we know:

- There are 14 repeats.
- Each repeat is a set of 18 instructions. I'll refer any given set of 18 instructions as a _block_.
- The sequence of instruction operations (e.g. `inp`, `add`, `mul`) are identical between blocks.
- 3 of the instructions show variance in their variables. In my data: these are the 5th, 6th and 16th instructions (which have been coloured in the example above).

So, what do the blocks do?

I've rewritten these instructions, along with their net effect:

<pre class="language-plaintext highlighter-rouge highlight">
     1          2          3          4                     Result?
     --------   --------   --------   --------   --------   ------------
 1   inp w      inp w      inp w      inp w      inp w      Input w (Any number 1 through 9)
 2   mul x 0    mul x 0    mul x 0    mul x 0    mul x 0    x = 0 (Reset x)
 3   add x z    add x z    add x z    add x z    add x z    x = z<sub>0</sub>
 4   mod x 26   mod x 26   mod x 26   mod x 26   mod x 26   x = z<sub>0</sub> % 26
 5   <red>div z 1    div z 1    div z 1    div z 1    div z 26   z<sub>1</sub> = z<sub>0</sub> // var1</red>
 6   <mag>add x 12   add x 12   add x 13   add x 12   add x -3   x = z<sub>0</sub> % 26 + var2</mag>
 7   eql x w    eql x w    eql x w    eql x w    eql x w    x = 1 if x == w (input), else 0
 8   eql x 0    eql x 0    eql x 0    eql x 0    eql x 0    x = 0 if x == 1, else 1
 9   mul y 0    mul y 0    mul y 0    mul y 0    mul y 0    y = 0 (Reset y)
10   add y 25   add y 25   add y 25   add y 25   add y 25   y = 25
11   mul y x    mul y x    mul y x    mul y x    mul y x    y = 25 if x == 1, else 0
12   add y 1    add y 1    add y 1    add y 1    add y 1    y = 26 if x == 1, else 1
13   mul z y    mul z y    mul z y    mul z y    mul z y    z<sub>2</sub> = 26(z<sub>0</sub> // var1) if x == 1, else z<sub>0</sub> // var1
14   mul y 0    mul y 0    mul y 0    mul y 0    mul y 0    y = 0 (Reset y)
15   add y w    add y w    add y w    add y w    add y w    y = w
16   <yellow>add y 7    add y 8    add y 2    add y 11   add y 6    y = w + var3</yellow>
17   mul y x    mul y x    mul y x    mul y x    mul y x    y = w + var3 if x == 1, else 0
18   add z y    add z y    add z y    add z y    add z y    z = 26(z<sub>0</sub> // var1) + w + var3 if x == 1, else 26(z<sub>0</sub> // var1)
</pre>

Some important observations:

- We read our next digit into `w` with each block.
- `x` and `y` are both reset in each block before we do anything with them.  Thus, the final values of `x` and `y` from the previous block are irrelevant.
- Each block updates the value of `z`, using the previous value of `z`.

**Thus `z` is the only variable that persists between blocks.**

That's handy, since `z` is the value we ultimately care about.  Recall that our goal is for `z` to be 0 when MONAD has finished.

Let's look at the 14 possible values of the 3 variables:

<pre class="language-plaintext highlighter-rouge highlight">
<red>var1</red>  <mag>var2</mag>  <yellow>var3</yellow>
<red>----</red>  <mag>----</mag>  <yellow>----</yellow>  
<red>   1</red>  <mag>  12</mag>  <yellow>   8</yellow>
<red>   1</red>  <mag>  13</mag>  <yellow>   2</yellow>
<red>   1</red>  <mag>  12</mag>  <yellow>  11</yellow>
<red>   1</red>  <mag>  12</mag>  <yellow>   7</yellow>
<red>  26</red>  <mag>  -3</mag>  <yellow>   6</yellow>
<red>   1</red>  <mag>  10</mag>  <yellow>  12</yellow>
<red>   1</red>  <mag>  14</mag>  <yellow>  14</yellow>
<red>  26</red>  <mag> -16</mag>  <yellow>  13</yellow>
<red>   1</red>  <mag>  12</mag>  <yellow>  15</yellow>
<red>  26</red>  <mag>  -8</mag>  <yellow>  10</yellow>
<red>  26</red>  <mag> -12</mag>  <yellow>   6</yellow>
<red>  26</red>  <mag>  -7</mag>  <yellow>  10</yellow>
<red>  26</red>  <mag>  -6</mag>  <yellow>   8</yellow>
<red>  26</red>  <mag> -11</mag>  <yellow>   5</yellow>
</pre>

Some observations:

- _var1_ can either be 1 or 26. In our 14 blocks, there are 7 of each.
- _var2_ is:
   - A positive integer >9, when _var1_ is 1. 
   - A negative integer, when _var_1 is 26.
- _var3_ is a variable positive integer.

Thus, there appear to be two types of _block_.

### Type 1 Block: var1 is 1, var2 > 9

<pre class="language-plaintext highlighter-rouge highlight">
     Block      Result?
     --------   ------------
 1   inp w      Input w (Any number 1 through 9)
 2   mul x 0    x = 0 (Reset x)
 3   add x z    x = z<sub>0</sub>
 4   mod x 26   x = z<sub>0</sub> % 26
 5   <red>div z 1    z<sub>1</sub> = z<sub>0</sub></red>
 6   <mag>add x 14   x = z<sub>0</sub> % 26 + var2</mag>
 7   eql x w    x = 0, since w is always <= 9, but var2 is always > 9.
 8   eql x 0    x = 1
 9   mul y 0    y = 0 (Reset y)
10   add y 25   y = 25
11   mul y x    y = 25
12   add y 1    y = 26
13   mul z y    z<sub>2</sub> = 26z<sub>0</sub>
14   mul y 0    y = 0 (Reset y)
15   add y w    y = w
16   <yellow>add y 7    y = w + var3</yellow>
17   mul y x    y = w + var3
18   add z y    z = 26z<sub>0</sub> + w + var3
</pre>

In summary:

\\(z_{next} = 26z_{prev} + w + a\\)

Where \\(a\\) is the variable from instruction 16.

### Type 2 Block: var1 is 26, var2 is negative

<pre class="language-plaintext highlighter-rouge highlight">
     Block      Result?
     --------   --------
 1   inp w      Input w (Any number 1 through 9)
 2   mul x 0    x = 0 (Reset x)
 3   add x z    x = z<sub>0</sub>
 4   mod x 26   x = z<sub>0</sub> % 26
 5   <red>div z 26   z<sub>1</sub> = z<sub>0</sub> // 26</red>
 6   <mag>add x -3   x = z<sub>0</sub> % 26 + var2</mag>
 7   eql x w    x = 1 if w == z<sub>0</sub> % 26 + var2, else 0
 8   eql x 0    x = 0 if x == 1, else 1
 9   mul y 0    y = 0 (Reset y)
10   add y 25   y = 25
11   mul y x    y = 0 if x == 0, else 25
12   add y 1    y = 1 if x == 0, else 26
13   mul z y    z<sub>0</sub> // 26 if x == 0, else z<sub>2</sub> = z<sub>0</sub>
14   mul y 0    y = 0 (Reset y)
15   add y w    y = w
16   <yellow>add y 6    y = w + var3</yellow>
17   mul y x    y = 0 if x == 0, else y = w + var3
18   add z y    z = z<sub>0</sub> // 26 if x == 0, else z = z<sub>0</sub> + w + var3
</pre>

Thus, there are two possible outcomes of a _Type 2 block_:

When final \\(x\\) `== 0`:`   `\\(z_{next} = z_{prev} // 26\\)

When final \\(x\\) `== 1`:`   `\\(z_{next} = z_{prev} + w + a\\)

### How to Solve

