---
day: 24
title: Day 24
main_img:
  name: ALU
  link: /assets/images/arithmetic-and-logic-unit.png
tags: 
  - name: Breadth First Search (BFS)
    link: https://www.redblobgames.com/pathfinding/a-star/introduction.html
---
## Solution Intro

_Oh, this one looks easy enough._  **Wrong!** \
_I just need to write an ALU simulator that knows how to process some instructions._ **Wrong!**

## Overview

We're told that the sub runs off an _arithmetic logic unit_ that takes four integer variables (`w`, `x`, `y`, and `z`), and is capable of performing dix different instructions with these variables.

The ALU processes programs, which are sets of instructions.  The instructions are procesed in order, from beginning to end.

We're given a few sample input programs. Like this one:

```text
inp w
add z w
mod z 2
div w 2
add y w
mod y 2
div w 2
add x w
mod x 2
div w 2
mod w 2
```

We're told we need to use our ALU to validate the sum's _model number_.  We're given a program called _MONAD_ which takes any 14-digit number (where the digits must be 1 to 9, inclusive), and processes the number.  My actual MONAD data, for example, 14 `inp w` instructions.

We're told a given _model number_ is only valid if, after processing all the instructions in the MONAD program, variable `z` is set to 0.

## Part 1

**What is the largest model number accepted by MONAD?**

So the goal is to find the largest possible 14-digit number which results in a `z` value of 0, after running the number through our program.

Having done a few AOCs before, I jumped straight to writing an ALU simulator. _(Spoiler alert: this was a mistake!)

```python
class ALU():
    """ Simulate processor with four registers and six instructions """
    def __init__(self) -> None:
        self._vars = {'w': 0, 'x': 0, 'y': 0, 'z': 0}
        
        self._input = None
        self._input_posn = 0
        
        self._instructions: list[tuple[str, list[str]]] = []     # list of instructions in the format [instr, [parms]]
        self._ip = 0
        
    @property
    def vars(self):
        return self._vars
    
    def _set_input(self, value: str):
        """ Take a number and store as a str representation """
        assert value.isdigit, "Must be number"
        assert len(value) == 14, "Must be 14 digit input"
        self._input = value
        self._input_posn = 0        
     
    def _set_var(self, var, value):
        """ Sets the specified var to the specified value. """
        if var not in self._vars:
            raise KeyError(f"No such var '{var}'")
        
        self._vars[var] = value
    
    def _reset(self):
        for var in self._vars:
            self._vars[var] = 0

        self._input = None
        self._input_posn = 0
        self._ip = 0
        
    def run_program(self, input_str):
        """ Process instructions in the program.
            - Converts the program input to a list of instructions and stores them in the computer.
            - Then executes the instructions one at a time.

        Args:
            instructions (list): Each instr is in the format ["instr params"], e.g. div z 1
        """
        self._reset()      
        self._set_input(input_str)
        
        for instruction in self._instructions:
            self._execute_instruction(instruction)
            self._ip += 1

    def set_program(self, instructions_input):
        """ Create a list of instructions, 
        where each instruction is of the format: (str, list[str]) """
        self._instructions = []
        
        for line in instructions_input:
            instr_parts = line.split()
            instr = instr_parts[0]
            instr_parms = instr_parts[1:]
        
            self._instructions.append((instr, instr_parms))
        
    def _execute_instruction(self, instruction:tuple[str, list[str]]):
        """ Takes an instruction, and calls the appropriate implementation method.

        Args:
            instr_and_parms (list): The instruction, in the format (instr, [parms])
            
        Raises:
            AttributeError if instruction is not understood
        """
        # logger.debug("Instruction: %s", instruction)
        instr = instruction[0]
        instr_parms = instruction[1]
        
        # call the appropriate instruction method
        try:
            self.__getattribute__(f"_op_{instr}")(instr_parms)
            # logger.debug(self)            
        except AttributeError as err:
            raise AttributeError(f"Bad instruction {instr} at {self._ip}") from err

    def int_or_reg_val(self, x) -> int:
        """ Determine if the variable is an int value, or the value in a register """
        if x in self._vars:
            return self._vars[x]
        else:
            return int(x)
        
    def _op_inp(self, parms:list[str]):
        var = parms[0]
        assert self._input, "Input value not set"
        assert self._input_posn < len(self._input), "Too many input digits!"
        # logger.debug("Reading input: %s into %s", self._input[self._input_posn], var)
        input_digit = int(self._input[self._input_posn])
        self._vars[var] = input_digit
        self._input_posn += 1
    
    def _op_add(self, parms:list[str]):
        """ Add a to b and store in a. Param b could be a var or a number. """
        self._vars[parms[0]] += self.int_or_reg_val(parms[1])
    
    def _op_mul(self, parms:list[str]):
        """ Multiply a by b and store in a. Param b could be a var or a number. """
        self._vars[parms[0]] *= self.int_or_reg_val(parms[1])
    
    def _op_div(self, parms:list[str]):
        """ Divide a by b and store in a. Param b could be a var or a number. """
        parm_b = self.int_or_reg_val(parms[1])
        assert parm_b != 0, "Integer division by 0 is bad."
        self._vars[parms[0]] //= parm_b
        
    def _op_mod(self, parms:list[str]):
        """ Modulo a by b and store in a. Param b could be a var or a number. """
        parm_a = self._vars[parms[0]]
        parm_b = self.int_or_reg_val(parms[1])
        try:
            assert parm_a >= 0 and parm_b != 0, "Integer division by 0 is bad." 
            self._vars[parms[0]] %= parm_b     
        except AssertionError as err:
            raise AttributeError(f"Bad instruction: {parm_a} mod {parm_b}") from err

    def _op_eql(self, parms:list[str]):
        """ Chec if a and b are equal. Store 1 if equal. Param b could be a var or a number. """
        self._vars[parms[0]] = 1 if self._vars[parms[0]] == self.int_or_reg_val(parms[1]) else 0
                 
    def __repr__(self):
        return f"{self.__class__.__name__}{self._vars}"  
```

