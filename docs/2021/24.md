---
day: 24
title: Day 24
main_img:
  name: ALU
  link: /assets/images/arithmetic-and-logic-unit.png
tags: 
  - name: introspection
    link: https://www.geeksforgeeks.org/code-introspection-in-python/
  - name: tqdm
  - name: progress bar
---
## Solution Intro

_Oh, this one looks easy enough._  **Wrong!** \
_I just need to write an ALU simulator that knows how to process some instructions._ **Wrong!**

## Overview

We're told that the sub runs off an _arithmetic logic unit_ that takes four integer variables (`w`, `x`, `y`, and `z`), and is capable of performing dix different instructions with these variables.

The ALU processes programs, which are sets of instructions.  The instructions are procesed in order, from beginning to end.

We're given a few sample input programs. Like this one:

```text
inp w
add z w
mod z 2
div w 2
add y w
mod y 2
div w 2
add x w
mod x 2
div w 2
mod w 2
```

We're told we need to use our ALU to validate the sum's _model number_.  We're given a program called _MONAD_ which takes any 14-digit number (where the digits must be 1 to 9, inclusive), and processes the number.  My actual MONAD data, for example, 14 `inp w` instructions.

We're told a given _model number_ is only valid if, after processing all the instructions in the MONAD program, variable `z` is set to 0.

## Part 1

**What is the largest model number accepted by MONAD?**

So the goal is to find the largest possible 14-digit number which results in a `z` value of 0, after running the number through our program.

Having done a few AOCs before, I jumped straight to writing an ALU simulator. _(Spoiler alert: this was a mistake!)_

```python
class ALU():
    """ Simulate processor with four registers and six instructions """
    def __init__(self) -> None:
        self._vars = {'w': 0, 'x': 0, 'y': 0, 'z': 0}
        
        self._input = None
        self._input_posn = 0
        
        self._instructions: list[tuple[str, list[str]]] = []     # list of instructions in the format [instr, [parms]]
        self._ip = 0
        
    @property
    def vars(self):
        return self._vars
    
    def _set_input(self, value: str):
        """ Take a number and store as a str representation """
        assert value.isdigit, "Must be number"
        assert len(value) == 14, "Must be 14 digit input"
        self._input = value
        self._input_posn = 0        
     
    def _set_var(self, var, value):
        """ Sets the specified var to the specified value. """
        if var not in self._vars:
            raise KeyError(f"No such var '{var}'")
        
        self._vars[var] = value
    
    def _reset(self):
        for var in self._vars:
            self._vars[var] = 0

        self._input = None
        self._input_posn = 0
        self._ip = 0
        
    def run_program(self, input_str):
        """ Process instructions in the program.
            - Converts the program input to a list of instructions and stores them in the computer.
            - Then executes the instructions one at a time.

        Args:
            instructions (list): Each instr is in the format ["instr params"], e.g. div z 1
        """
        self._reset()      
        self._set_input(input_str)
        
        for instruction in self._instructions:
            self._execute_instruction(instruction)
            self._ip += 1

    def set_program(self, instructions_input):
        """ Create a list of instructions, 
        where each instruction is of the format: (str, list[str]) """
        self._instructions = []
        
        for line in instructions_input:
            instr_parts = line.split()
            instr = instr_parts[0]
            instr_parms = instr_parts[1:]
        
            self._instructions.append((instr, instr_parms))
        
    def _execute_instruction(self, instruction:tuple[str, list[str]]):
        """ Takes an instruction, and calls the appropriate implementation method.

        Args:
            instr_and_parms (list): The instruction, in the format (instr, [parms])
            
        Raises:
            AttributeError if instruction is not understood
        """
        # logger.debug("Instruction: %s", instruction)
        instr = instruction[0]
        instr_parms = instruction[1]
        
        # call the appropriate instruction method
        try:
            self.__getattribute__(f"_op_{instr}")(instr_parms)          
        except AttributeError as err:
            raise AttributeError(f"Bad instruction {instr} at {self._ip}") from err

    def int_or_reg_val(self, x) -> int:
        """ Determine if the variable is an int value, or the value in a register """
        if x in self._vars:
            return self._vars[x]
        else:
            return int(x)
        
    def _op_inp(self, parms:list[str]):
        var = parms[0]
        assert self._input, "Input value not set"
        assert self._input_posn < len(self._input), "Too many input digits!"
        # logger.debug("Reading input: %s into %s", self._input[self._input_posn], var)
        input_digit = int(self._input[self._input_posn])
        self._vars[var] = input_digit
        self._input_posn += 1
    
    def _op_add(self, parms:list[str]):
        """ Add a to b and store in a. Param b could be a var or a number. """
        self._vars[parms[0]] += self.int_or_reg_val(parms[1])
    
    def _op_mul(self, parms:list[str]):
        """ Multiply a by b and store in a. Param b could be a var or a number. """
        self._vars[parms[0]] *= self.int_or_reg_val(parms[1])
    
    def _op_div(self, parms:list[str]):
        """ Divide a by b and store in a. Param b could be a var or a number. """
        parm_b = self.int_or_reg_val(parms[1])
        assert parm_b != 0, "Integer division by 0 is bad."
        self._vars[parms[0]] //= parm_b
        
    def _op_mod(self, parms:list[str]):
        """ Modulo a by b and store in a. Param b could be a var or a number. """
        parm_a = self._vars[parms[0]]
        parm_b = self.int_or_reg_val(parms[1])
        try:
            assert parm_a >= 0 and parm_b != 0, "Integer division by 0 is bad." 
            self._vars[parms[0]] %= parm_b     
        except AssertionError as err:
            raise AttributeError(f"Bad instruction: {parm_a} mod {parm_b}") from err

    def _op_eql(self, parms:list[str]):
        """ Chec if a and b are equal. Store 1 if equal. Param b could be a var or a number. """
        self._vars[parms[0]] = 1 if self._vars[parms[0]] == self.int_or_reg_val(parms[1]) else 0
                 
    def __repr__(self):
        return f"{self.__class__.__name__}{self._vars}"  
```

So what does this do?

- When we create an `ALU` object, we initialise our four variables to 0, in dict.
- We maintain an index pointer - `_input_posn` - that points to the position of the current digit being processed, in our 14-digit number.  Recall that we act on one digit at a time from this number, every time we see an `inp` instruction.
- We also maintain an instruction pointer - `_ip` - that points to the current instruction being processed in the program.
- We have a convenience property, `vars` to allow an external program to read the current value of any of the variables.
- We define the program that the ALU will run, by running `set_program()`, passing in a list of of instructions. This takes each instruction line, and converts each to an instruction part (`instr`), and a parameters part (`instr_parms`).
- We run the input program using the `run_program()` method, which expects the 14 digit value as input. It then iterates through all instruction pairs, running `_execute_instruction()` for each.
  - Within the `_execute_instruction()`, we now do a bit of **introspection**.  This is where we use Python to examine its own objects at run time, in order to determine information about those objects.  Specifically, we're using the `__getattribute__()` method, and passing in a `str`, in order to identify any attribute (or method) that matches the `str` passed in.
  - We've created a number of _methods_ in the `ALU` class, such as `_op_inp()`, `op_add()`, `op_mul()`.  So, when we do something like `self.__getattribute__(f"_op_{instr}")`, passing in the `instr` type from the current instruction, Python actually returns the _method_ with that name, and runs it!!  Thus, this is a clever way to map a bunch of method names to a bunch of instructions.

Great!  So now all we have to do is create the `ALU`, initialise the program to our set of instructions, and then run it with every possible 14 digit number that doesn't contain a 0.  We could do something like this:

```python
input_file = os.path.join(SCRIPT_DIR, INPUT_FILE)
with open(input_file, mode="rt") as f:
    data = f.read().splitlines()

alu = ALU()
alu.set_program(data)
for int_val in tqdm(range(99999999999999, 11111111111110, -1)):
    val = str(int_val)
    if '0' in val:
        continue
    
    alu.run_program(val)
    if alu.vars['z'] == 0:
        logger.info("%s verified.", val) 
```

As I've done with an earlier program, I've wrapped my `for` loop with `tqdm`, in order to give me a progress bar for this long running loop.  Usefully, the progress bar includes an estimated completion time. So yeah... It's going to take about 200 years.  We're going to need a bigger boat.  Or a better solution.

**TIME TO THROW ALL THAT AWAY!**