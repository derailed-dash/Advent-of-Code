---
day: 23
title: Day 23
main_img:
  name: Amphipods
  link: /assets/images/amphipods.jpg
tags: 
  - name: Breadth First Search (BFS)
    link: https://www.redblobgames.com/pathfinding/a-star/introduction.html
  - name: heapq
    link: https://realpython.com/python-heapq-module/
---
## Solution Intro

Yep, this one was hard too.  Not as hard as yesterday though.  It was much easier to see how to do the solution.

### Overview

We're told we have four types of amphipods, labelled `A`, `B`, `C` and `D`. They live in burrow made up of a hallway and side rooms. Each room is full of amphipods, using a configuration given as our starting input.

The sample input looks like this:

```txt
#############
#...........#
###B#C#B#D###
  #A#D#C#A#
  #########
```

Empty space is denoted by `.`.

## Part 1

**What is the least energy required, in order to rearrange the amphipods such that all the `A` pods are in the first hall, all of the `B` pods are in the second, and so on?**

So ultimately, we need to end up in this configuration:

```txt
#############
#...........#
###A#B#C#D###
  #A#B#C#D#
  #########
```

There are **rules** to amphipod movement:

- They can move to an unoccuped space.
- They cannot move past another amphipod.
- They are not allowed to stop in the hall if they stop immediately above (and thus block) a room. Otherwise, any empty space in the hall is fair game.
- They are only allowed to move into a room, if that room is their correct target room. E.g. a `B` pod can only enter the second (`B`) room. A `C` pod can only enter the third (`C`) room. 
- Furthermore, an amphipod will not enter their target room, if it has any 'wrong' amphipods in it. E.g. if the second room contains a `B`, then a `B` can enter it.  But if the second room contains a `C`, then nothing can enter this room.
- If an amphipod stops in the hallway, it cannot move again, unless it is moving directly to its target room.
- Lastly, amphipod movement requires different amounts of energy:
  - `A = 1 per step`
  - `B = 10 per step`
  - `C = 100 per step`
  - `D = 1000 per step`

Thus, it's intuitively obvious that `D` pods need to move as little as possible!

For me, there were two obvious ways to go about this:

1. With a **Dijkstra breadth first search (BFS)**.
   - I.e. where we track the current _burrow state_.
   - We have a method that returns all possible _next_ states.
   - We then use Dijkstra BFS to trawl through states from start to goal, but favouring moves with the lowest cost. (That's what Dijkstra is good for!)
1. With **recursion with memoization**.
   - We use recursion to determine all possible next states, depth first.
   - We stop when we find a state that is the goal.
   - We use memoization to ensure that if we recurse into a state we've seen before, we immediately pop out the lowest cost answer that we've previously evaluated.

Personally, I like the Dijkstra approach more.  So that's what I'm going to describe here.

Let's start with reading in the data:

```python
input_file = os.path.join(SCRIPT_DIR, INPUT_FILE)
with open(input_file, mode="rt") as f:
    data = f.read().splitlines()

# Part 1
# Process data with initial state of our four rooms
room_a: list[str] = []
room_b: list[str] = []
room_c: list[str] = []
room_d: list[str] = []
hall: list[str] = []

for line in data:   # we only care about chars in "ABCD."
    for x, char in enumerate(line):
        if char == ".":     # hall
            hall.append(char)
        if char in "ABCD":  # rooms
            if x == 3:
                room_a.append(char)
            if x == 5:
                room_b.append(char)
            if x == 7:
                room_c.append(char)
            if x == 9:
                room_d.append(char) 
```

I'm representing the four rooms, and the hall, with `lists` that can only contain `str`.

- The hall will be a `list` with 11 items.
  - Each item can be either `.` or an amphipod type, `A`, `B`, `C`, or `D`.
  - Initially, the hall is empty. We rely on this when parsing the data. I.e. any `.` will be considerd a hall character.
- A room will be a `list` with two items. 
  - Each item can be either `.` or an amphipod type, `A`, `B`, `C`, or `D`.
  - Initially, none of the rooms are empty. We rely on this when parsing the data. I.e. any char that is `in "ABCD"` will be considered a room character.

  



