---
day: 15
title: Day 15
problem: Chiton
main_img:
  name: Chitons
  link: /assets/images/chitons.jpg
tags: 
  - name: dataclass
  - name: Priority queue
  - name: heapq
    link: https://realpython.com/python-heapq-module/
  - name: Dijkstraâ€™s Algorithm
    link: https://www.redblobgames.com/pathfinding/a-star/introduction.html
---
## Solution Intro

We're in a cavern with a low ceiling just above us, so we can only navigate in two dimensions. I.e. we can't go up or down. The cavern makes up a graph of connected locations that we need to navigate through. We're told that the cave walls are covered in chitons, and don't want to bump into them!

Our sub's computer has mapped out the chiton density, and converted this into grid of risk level, in the two dimensions we can navigate.

The input data looks like this:

```
1163751742
1381373672
2136511328
3694931569
7463417111
1319128137
1359912421
3125421639
1293138521
2311944581
```

We start in the top left. We can navigate the maze by moving in any orthogonal direction; we can't move diagonally.

## Part 1

We need to get to the bottom right, and we need to compute the **total risk** of the **lowest risk route**. Total risk is given by adding up the risk of every location we enter; thus, the risk of our starting location is not counted.

### Setup

The usual stuff...

```python
from __future__ import annotations
from copy import deepcopy
from dataclasses import dataclass
import logging
import os
import time
import heapq

SCRIPT_DIR = os.path.dirname(__file__) 
INPUT_FILE = "input/input.txt"
# INPUT_FILE = "input/sample_input.txt"

logging.basicConfig(format="%(asctime)s.%(msecs)03d:%(levelname)s:%(name)s:\t%(message)s", 
                    datefmt='%H:%M:%S')
logger = logging.getLogger(__name__)
logger.setLevel(level=logging.DEBUG)
```

The only new addition worthy of mention is the **`heapq`** module. This allows us to implement a **priority queue**. More on this later.

### Solution

This is simple enough. We're going to use a bog-standard **Dijkstra** solution.

Recall that in [Day 9](9) we used a Breadth First Search (BFS) to flood fill an area.  And in [Day 12](12) we again used the BFS to find all the paths between a starting point and a destination.

Well, **Dijkstra builds on the BFS** algorithm, by allowing us to **prioritise the paths we want to explore first, favouring paths with a lower cost.** Thus, Dijkstra is a great algorithm to allow us to find the _best_ path through a graph, where _best_ might mean _shortest_, _fastest_, _lowest_cost_, etc. It's also particularly suited to where movement in the graph may have _variable cost_.

And this is exactly the scenario we have here: some locations have higher risk scores.  So, we want to prioritise the path that has the overall lowest risk cost.

The Dijkstra works just like the BFS, in that it uses a frontier that expands in all valid directions.  However, unlike a BFS where we typically pop items off the frontier in the order they were added (FIFO), Dijkstra instead uses a **priority queue** for the frontier, where we pop off items that have the _lowest priority_.  (Here, _lowest_ could actually be _highest_; it really depends what behaviour you want.)

For our solution, we want to prioritise based on _lowest cumulative risk_. So, we do this by keeping track of our path and the total risk for our path.  And as we explore the next possible move for each path, we always explore the path that has the lowest cumulative risk, first.

We'll start with a `Point` dataclass:

```python
@dataclass(frozen=True, order=True)
class Point():
    """ Point class, which knows how to return a list of all adjacent coordinates """
    
    # Return all adjacent orthogonal (not diagonal) coordinates
    DELTAS = [(dx,dy) for dx in range(-1, 2) for dy in range(-1, 2) if abs(dy) != abs(dx)]
    
    x: int
    y: int
    
    def neighbours(self) -> list[Point]:
        """ Return all adjacent orthogonal (not diagonal) Points """
        return [Point(self.x+dx, self.y+dy) for dx,dy in Point.DELTAS]
```

Now let's create a `Grid` class to represent our input of risks:

```python
class Grid():
    """ 2D grid of point values. Knows how to:
       - Determine value at any point
       - Determine all neighbouring points of a given point """
       
    def __init__(self, grid_array: list[list[int]]) -> None:
        """ Generate Grid instance from 2D array. 
        This works on a deep copy of the input data, so as not to mutate the input. """                                         
        self._array = deepcopy(grid_array)  # Store a deep copy of input data
        self._x_size = len(self._array[0])
        self._y_size = len(self._array)
        
    @property
    def x_size(self):
        """ Array width (cols) """
        return self._x_size
    
    @property
    def y_size(self):
        """ Array height (rows) """
        return self._y_size
    
    @property
    def array(self):
        return self._array
    
    def set_value_at_point(self, point: Point, value: int):
        self._array[point.y][point.x] = value
        
    def value_at_point(self, point: Point) -> int:
        """ Value at this point """
        return self._array[point.y][point.x]
    
    def _valid_location(self, point: Point) -> bool:
        """ Check if a location is within the grid """
        if (0 <= point.x < self.x_size and  0 <= point.y < self.y_size):
            return True
        
        return False
    
    def valid_neighbours(self, point:Point):
        """ Yield adjacent neighbour points """
        for neighbour in point.neighbours():
            if self._valid_location(neighbour):
                yield neighbour
    
    def __repr__(self) -> str:
        return "\n".join("".join(map(str, row)) for row in self._array)
```


## Part 2

