---
day: 21
title: Day 21
main_img:
  name: Splitting Time
  link: /assets/images/splitting_time.png
tags: 
  - name: lru_cache
    link: https://www.geeksforgeeks.org/python-functools-lru_cache/
  - name: itertools.product
    link: https://www.geeksforgeeks.org/python-itertools-product/
  - name: Abstract class
    link: https://www.geeksforgeeks.org/abstract-classes-in-python/
  - name: ABC
    link: https://www.geeksforgeeks.org/abstract-classes-in-python/
  - name: generator
    link: https://www.pythonforbeginners.com/basics/generators-in-python
  - name: yield
---
## Solution Intro

Okay, we're going to play a game of **Dirac Dice**. Part 1 was nice and easy.  Part 2 nearly broke my brain.

So, we have two _players_ (each with their own _pawn_), a single _die_, and a game board with a circular track. The track contains 10 _spaces_, marked `1` through `10`.

![Diract Board]({{"/assets/images/dirac_board.jpg" | relative_url }}){:style="width:300px"}

We're told:

- Players start with a score of 0. 
- Each player starts on a random space. The starting space does not contribute to the initial player score. 
- Players take turns. On a player's turn, the player rolls the die 3 times.
- The sum of the die rolls is the number of spaces they move, clockwise.  Whatever space they land on, that is the score they are awarded for that turn.  This is added to their existing score.

## Part 1

We're given a _100 sided deterministic die_.  I.e. every roll of the die returns an incrementing number from `1` to `100`.  When it gets to `100`, we go back to `1`.  The game is won when a player reaches a score of at least 1000.

**What is the product of the score of the losing player and the number of times the die was rolled in the game?**

This is quite an easy problem, and we get to play with a few new things.

### Setup

Some new things here, which we'll cover as we get to them.

```python
from abc import ABC, abstractmethod
from functools import lru_cache
import logging
import os
import time
from typing import Iterator, NamedTuple
from copy import deepcopy
from itertools import product

SCRIPT_DIR = os.path.dirname(__file__) 
INPUT_FILE = "input/input.txt"
# INPUT_FILE = "input/sample_input.txt"

logging.basicConfig(format="%(asctime)s.%(msecs)03d:%(levelname)s:%(name)s:\t%(message)s", 
                    datefmt='%H:%M:%S')
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
```

### Solution

First, a class for the players:

```python
class Player(NamedTuple):
    """ A player has a current position on the board, and a cumulative score """
    posn: int
    score: int
```

This subclasses `NamedTuple`.  It's a lot like the more powerful `Dataclass`. It allows us to create a class which is actually a `tuple`, but where the attributes of the `tuple` can be referenced by name.

Now we'll create an _abstract_ class, called `AbstractDie`:

```python
class AbstractDie(ABC):
    """ Abstract die """
    def __init__(self, faces: int) -> None:
        self._faces = faces
        self._total_rolls = 0   # How many times have we rolled this die
        self._roll_gen = self._roll()   # A generator that performs the roll.
            
    @property
    def total_rolls(self):
        return self._total_rolls
    
    def roll(self):
        """ This is how we roll the die. Calls next() on the roll generator. """
        return next(self._roll_gen)
    
    @abstractmethod
    def _roll(self) -> Iterator[int]:
        """ We need to override this method. """
        return NotImplemented
```

The concept of an _abstract_ class is that it provides some functionality that we can reuse in subclasses, but the abstract class itself _cannot be instantiated_. This is because the _abstract_ class has one or more _abstract methods_, meaning that these methods do not yet have any actual implementation. So when we extend the abstract class, we need to provide an implementation for any _abstract methods_. In our `AbstractDie`, we can see that the `_roll()` method lacks any implementation, and is decorated as `@abstractmethod`.

Note that our `AbstractDie` class in inherits from `ABC`, i.e. the _abstract base class_.  This is what marks our class as _abstract_.

If we try to do something like this:

```python
die = AbstractDie(faces=100)
```

Then we'll get an error like this:

```
TypeError: Can't instantiate abstract class AbstractDie with abstract method _roll
```

Other things to note about our `AbstractDie`:

- It sets the instance variable `_roll_gen` to point to the `_roll()` method.  It expects that method to be a _generator_.  I.e. a form of iterator that returns a new object whenever the generator is passed to `next()`.
- Furthermore, we provide a public method `roll()`, which actually returns the `next()` item from our `generator`.

Now let's implement our `DeterministicDie`:

```python
class DeterministicDie(AbstractDie):
    """ Subclass of AbstractDie. Persists state between rolls.
    Always yields an incrementing int from the number of available faces, starting at 1.
    E.g. from 1-100. When we get to the number of faces, we wrap back around to 1. """
    
    def _roll(self) -> Iterator[int]:
        """ Yield the next available number. """
        while True:
            for i in range(1, self._faces+1):
                self._total_rolls += 1
                yield i
```

Nice and short.  This is a _subclass_ of `AbstractDie`, so we only need to override the _abstract method_, i.e. the `_roll()` method.  This method _yields_ incrementing values of i (i.e. from 1 to 100), and then wraps back around to 1, by virtue of being in an infinite `while True` loop. Note the use of the **yield** keyword here.  It works like a `return` statement, but allows the method execution to continue on the very next method line, when we next call the method.  E.g. if `i` has a value of `50` and we've just yielded that value, then when we next call `roll()`, which in turn calls `next()` on our `_roll()` method, then the method will continue within the `for` loop, setting `i` to `51`.

Now let's define a class for the `Game` itself:

```python
class Game():
    """ We're on a circular track, with grid numbers 1 to 10. The player moves around the circle with each go.
    If the player lands on number x, the player gains x points.
    The player starts on an arbitrary grid number, and with a score of 0. """
    SPACES = 10
    ROLLS_PER_TURN = 3    
    
    def __init__(self, players: list[Player], die: AbstractDie, target: int) -> None:
        self._players = players  # Our two players.
        self._die = die          # Our die may be deterministic, so we need to store die state
        self._target = target    # The score a player needs to reach, to win the game    
    
    @property
    def players(self):
        return self._players
    
    @property
    def die(self):
        return self._die
    
    def play(self) -> int:
        """ Play a game. Each player takes a turn, until the target score is reached by a player. """
        while True:
            for player_num in range(len(self.players)):
                score = self._take_turn(player_num)
                if score >= self._target:   # This player has won!
                    return player_num
        
        assert False, "Game should end!"
        
    def _take_turn(self, player_num: int) -> int:
        """ Takes a turn for this player.  Roll the die n (e.g. 3) times, to give score x.
        Then move around the circle x places.  Whatever we land on, that's the score returned.
        Add this to existing score. Update the player.  Returns the cumulative score of the player """

        old_posn, old_total = self.players[player_num] # unpack the player
        
        die_score = sum(self._die.roll() for i in range(Game.ROLLS_PER_TURN)) # Roll n times
        new_posn = (((old_posn + die_score)-1) % Game.SPACES) + 1 # Move forward n spaces
        new_total = old_total + new_posn  # Add new board position to existing player score
        self.players[player_num] = Player(new_posn, new_total)  # Update the player
        
        return new_total
```

After some basic `Game` initialisation, the game is played by calling `play()` on our `Game` instance.

- We alternate between our two players, i.e. through `_take_turn(player_num)`.
- Taking a turn results in the player landing on a new space, which returns a new cumulative score.  
- If the score exceeds the target (i.e. 1000), then the game ends.

The `_take_turn()` method:

- Gets the current player position and score.
- Performs our three die rolls, and then gets the `sum` of those rolls.
- Determines the new position, by moving forward the number of spaces given the sum of the die rolls.
- Updates the player's score, based on that new position.

Finally, we run it:

```python
    input_file = os.path.join(SCRIPT_DIR, INPUT_FILE)
    with open(input_file, mode="rt") as f:
        data = f.read().splitlines()

    init_players: list[Player] = []
    for line in data:
        tokens = line.split() # Into 5 tokens, e.g. "Player" "1" "starting" "position:" "4"
        init_players.append(Player(posn=int(tokens[-1]), score=0))
    
    # Part 1
    players = deepcopy(init_players)
    die = DeterministicDie(faces=100)
    game = Game(players, die, target=1000)
    won = game.play()
    
    total_rolls = game.die.total_rolls
    logger.info("Die has been rolled %d times", total_rolls)
    logger.info("Player %d won with score of: %d", won+1, players[won].score)
    logger.info("Part 1 result = %d\n", total_rolls * min(player.score for player in game.players))
```

- We start by parsing the input `str` for the player number and starting positions.  We create `Player` objects, accordingly. We set their scores to 0.
- We then create a 100-sided `DeterministicDie`.