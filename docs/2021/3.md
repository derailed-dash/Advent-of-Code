---
year: 2021
day: 3
title: Day 3
problem: Binary Diagnostic
---
{% assign the_year = site.data.navigation.pages | where: 'name', page.year %}
{% assign next = page.day | plus: 1 %}
{% assign prev = page.day | minus: 1 %}
{% assign prev_page = the_year[0].members | where: 'name', prev %}
{% assign next_page = the_year[0].members | where: 'name', next %}
<img src="{{'/assets/images/bin_diag.jpg' | relative_url }}" alt="diving" style="margin:15px 10px 10px 10px; float: right; width:400px" />

# {{ page.AoC }} {{ page.year }} - {{ page.title }}

## Useful Links
{% if prev_page[0] %}
<button class="dazbo-button" onclick="window.location.href='{{ prev_page[0].link | relative_url }}';">&#8249;</button>
{%- endif -%}
{%- if next_page[0] -%}
<button class="dazbo-button" onclick="window.location.href='{{ next_page[0].link | relative_url }}';">&#8250;</button>
{% endif %}

- [2021 Main Page]({{ the_year[0].link | relative_url }})
- [My solution code]({{ site.github.repository_url }}/tree/master/src/AoC_2021){:target="_blank"}
- AoC page: [{{ page.problem }}](https://adventofcode.com/{{ page.year }}/day/{{ page.day }}){:target="_blank"}

## Solution Intro

So the warm-ups are over, and {{ page.title }} presents the first non-trivial challenges.

Today's problem requires us to decode a list of fixed-length binary numbers in order to obtain diagnostic information about the sub. The input data looks like this...

```
00100
11110
10110
10111
10101
```

### Setup

The only new class we're going to use for this solution is the awesome `Counter` class, from the `collections` module.

```python
import logging
import os
import time
from collections import Counter

SCRIPT_DIR = os.path.dirname(__file__) 
INPUT_FILE = "input/input.txt"
# INPUT_FILE = "input/sample_input.txt"

logging.basicConfig(format="%(asctime)s.%(msecs)03d:%(levelname)s:%(name)s:\t%(message)s", 
                    datefmt='%Y-%m-%d %H:%M:%S')
logger = logging.getLogger(__name__)
logger.setLevel(level=logging.DEBUG)
```

### Part 1

The goal for part 1 is to parse a list of depth figures, and count how many times the depth increases.

```python
    input_file = os.path.join(SCRIPT_DIR, INPUT_FILE)
    with open(input_file, mode="rt") as f:
        data = f.read().splitlines()
    
    # Part 1
    transposed = list(zip(*data))   # transpose to get list of columns
    
    most_common_bits = "".join([Counter(current_col).most_common()[0][0] for current_col in transposed])
    logger.debug("Gamma rate: %s", most_common_bits)
    least_common_bits = "".join([Counter(current_col).most_common()[-1][0] for current_col in transposed])
    logger.debug("Epsilon rate: %s", least_common_bits)
    
    logger.info("Part 1: Product = %d\n", int(most_common_bits, 2) * int(least_common_bits, 2))
```

### Part 2

Now the challenge is a tiny bit harder.  Rather than comparing each number to the last,
we now need to compare a sliding window of 3 numbers to the previous 3 numbers.

```python
```

And that's it!

{% if prev_page[0] %}
<button class="dazbo-button" onclick="window.location.href='{{ prev_page[0].link | relative_url }}';">&#8249;</button>
{%- endif -%}
{%- if next_page[0] -%}
<button class="dazbo-button" onclick="window.location.href='{{ next_page[0].link | relative_url }}';">&#8250;</button>
{% endif %}