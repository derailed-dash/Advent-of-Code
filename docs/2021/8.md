---
day: 8
title: Day 8
problem: Seven Segment Search
main_img:
  name: Crabs to the rescue
  link: /assets/images/four_digit_display.jpg
tags: 
  - name: sets
  - name: brute force
  - name: defaultdict
  - name: permutations
    link: https://www.geeksforgeeks.org/python-itertools-permutations/
---
## Solution Intro

Here I've documented two different approaches to this problem:

- [Solution #1](#solution-1) - Using sets and the structure of digits
- [Solution #2](#solution-2) - Brute force mapping

We're told that the sub's four-digit display is malfunctioning.  Each digit of the display is made up of 7 segments, labelled `a` through `g`. Each of the four digits has 7 output signal wires. Generating any given digit 0-9 is achieved by turning on the appropriate output signals, as shown here:

```
  0:      1:      2:      3:      4:      5:      6:      7:      8:      9:
 aaaa    ....    aaaa    aaaa    ....    aaaa    aaaa    aaaa    aaaa    aaaa
b    c  .    c  .    c  .    c  b    c  b    .  b    .  .    c  b    c  b    c
b    c  .    c  .    c  .    c  b    c  b    .  b    .  .    c  b    c  b    c
 ....    ....    dddd    dddd    dddd    dddd    dddd    ....    dddd    dddd
e    f  .    f  e    .  .    f  .    f  .    f  e    f  .    f  e    f  .    f
e    f  .    f  e    .  .    f  .    f  .    f  e    f  .    f  e    f  .    f
 gggg    ....    gggg    gggg    ....    gggg    gggg    ....    gggg    gggg 
```

Our problem is that the output wires have become scrambled. And worse than that, the scrambling is not consistent between digits on the four-digit display.

Our input data is given in the format of multiple lines, where each line contains:

- 10 unique signal patterns generated, i.e. signal outputs corresponding to digits 0-9 (but in no particular order)
- A 4 digit output we need to decode

So the input data looks like this:

```
be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb | fdgacbe cefdb cefbgd gcbe
edbfga begcd cbg gc gcadebf fbgde acbgfd abcde gfcbed gfec | fcgedb cgb dgebacf gc
fgaebd cg bdaec gdafb agbcfd gdcbef bgcad gfac gcb cdgabef | cg cg fdcagb cbg
fbegcd cbd adcefb dageb afcb bc aefdc ecdab fgdeca fcdbega | efabcd cedba gadfec cb
...
```

## Part 1

We're asked to determine how many times any of the digits 1, 4, 7, or 8 appear in the **output** data.  These are referred to as the _easy_ digits, on the basis that these numbers are generated by unique numbers of output signals.  E.g. if we look at the sample data and see an output signal `be`, then that must be generating a `1`, because `1 ` is the only digit that is produced from just two signals.

## Solution #1

This solution depends on us understanding the structure of each digit.  E.g. we know that a 1 is composed of 2 segments, a 7 is composed of 3 segments, etc.

Our solution for part 1 is this:

- Read in the signals and output values into two lists of sorted strings.
- Store a dictionary that maps _easy_ digits to signal counts.
- For each output digit, determine if they contain signal counts that correspond to an _easy_ digit.
- Finally, count how many _easy_ digits were produced.

```python
unique_segment_counts = {2: 1, 4: 4, 3: 7, 7: 8}   # {count: digit}

input_file = os.path.join(SCRIPT_DIR, INPUT_FILE)
with open(input_file, mode="rt") as f:
    data = f.read().splitlines()

signals = []      # list of lists of sorted input values
outputs = []            # list of lists of sorted output values
for line in data:
    digit_signals, four_digit_outputs = line.split("|")
    signals.append(["".join(sorted(signal)) for signal in digit_signals.split()])
    outputs.append(["".join(sorted(signal)) for signal in four_digit_outputs.split()])

# Part 1
all_easy_digits = []
for output_line in outputs:
    # Determine which digits in the output are in 1, 4, 7, 8
    easy_digits = [output for output in output_line if len(output) in unique_segment_counts]
    all_easy_digits.append(easy_digits)  # append, e.g. ['bcg', 'abcdefg', 'cg']
    
sum_of_easy_digits = sum([len(digits) for digits in all_easy_digits])   # count all
logger.info("Sum of easy digits: %d", sum_of_easy_digits)
```

## Part 2

We now need to decode all the output digits (not just the _easy_ ones).

```python

python

And the output looks like this:

```
2022-01-12 13:57:56.124:INFO:__main__:  Part 1 min cost: (350, 345035)
2022-01-12 13:57:56.461:INFO:__main__:  Part 2 min cost: (478, 97038163)
2022-01-12 13:57:56.461:INFO:__main__:  Execution time: 0.5585 seconds
```

## Solution #2

Here we're going to use both [NumPy](https://numpy.org/devdocs/user/quickstart.html){:target="_blank"} and [SciPy](https://docs.scipy.org/doc/scipy/tutorial/general.html){:target="_blank"}. This makes for much shorter code!



```python
import logging
import os
import time
import numpy as np
from scipy import optimize

SCRIPT_DIR = os.path.dirname(__file__) 
INPUT_FILE = "input/input.txt"
# INPUT_FILE = "input/sample_input.txt"

logging.basicConfig(format="%(asctime)s.%(msecs)03d:%(levelname)s:%(name)s:\t%(message)s", 
                    datefmt='%H:%M:%S')
logger = logging.getLogger(__name__)
logger.setLevel(level=logging.DEBUG)

input_file = os.path.join(SCRIPT_DIR, INPUT_FILE)
data: np.ndarray = np.loadtxt(input_file, delimiter=",", dtype=np.int32)

# minimize_scaler expects the function as first param, and args are any additional params the func requires
cost_part_1 = optimize.minimize_scalar(cost, args=(data))
logger.info("Part 1 min cost: %s", round(cost_part_1.fun))

cost_part_2 = optimize.minimize_scalar(cost, args=(data, lambda n: n*(n+1)/2))
logger.info("Part 2 min cost: %s", round(cost_part_2.fun)) 

def cost(posn: int, data: np.ndarray, cost_func=lambda n: n) -> int:
    """ Return the sum of applying the cost_func to get to position n, for every item in the array. """
    return cost_func(np.abs(posn-data)).sum()
```

Output:

```
2022-01-12 19:48:56.137:INFO:__main__:  Part 1 min cost: 345035
2022-01-12 19:48:56.137:INFO:__main__:  Part 2 min cost: 97038064
2022-01-12 19:48:56.137:INFO:__main__:  Execution time: 0.0033 seconds
```

Same answer, but over 100x faster!