---
day: 8
title: Day 8
problem: Seven Segment Search
main_img:
  name: Crabs to the rescue
  link: /assets/images/four_digit_display.jpg
tags: 
  - name: sets
  - name: brute force
  - name: defaultdict
  - name: permutations
    link: https://www.geeksforgeeks.org/python-itertools-permutations/
---
## Solution Intro

Here I've documented two different approaches to this problem:

- [Solution #1](#solution-1) - Using sets and the structure of digits
- [Solution #2](#solution-2) - Brute force mapping

We're told that the sub's four-digit display is malfunctioning.  Each digit of the display is made up of 7 segments, labelled `a` through `g`. Each of the four digits has 7 output signal wires. Generating any given digit 0-9 is achieved by turning on the appropriate output signals, as shown here:

```
  0:      1:      2:      3:      4:      5:      6:      7:      8:      9:
 aaaa    ....    aaaa    aaaa    ....    aaaa    aaaa    aaaa    aaaa    aaaa
b    c  .    c  .    c  .    c  b    c  b    .  b    .  .    c  b    c  b    c
b    c  .    c  .    c  .    c  b    c  b    .  b    .  .    c  b    c  b    c
 ....    ....    dddd    dddd    dddd    dddd    dddd    ....    dddd    dddd
e    f  .    f  e    .  .    f  .    f  .    f  e    f  .    f  e    f  .    f
e    f  .    f  e    .  .    f  .    f  .    f  e    f  .    f  e    f  .    f
 gggg    ....    gggg    gggg    ....    gggg    gggg    ....    gggg    gggg 
```

Our problem is that the output wires have become scrambled. And worse than that, the scrambling is not consistent between digits on the four-digit display.

Our input data is given in the format of multiple lines, where each line contains:

- 10 unique signal patterns generated with this, i.e. signal outputs corresponding to digits 0-9 (but in no particular order)
- A 4 digit output

```
```

## Part 1

Given the current crab positions, and with each 1 unit horizontal move by a crab costing 1 fuel, move all the crabs to the horizontal position that costs the least fuel. What is the total fuel cost?

## Solution #1

We start by reading the input data, splitting the data at the commas, and converting each input value to an `int`. (Nothing new here.)

```python
input_file = os.path.join(SCRIPT_DIR, INPUT_FILE)
with open(input_file, mode="rt") as f:
    data = [int(x) for x in f.read().split(",")]
    
logger.info("Part 1 min cost: %s", get_min_cost(data))
```

## Part 2

Now we're told that the cost per unit of horizontal crab movement increases with distance. So, moving 1 unit costs 1, moving a second unit costs 2, moving a third unit costs 3.

And the output looks like this:

```
2022-01-12 13:57:56.124:INFO:__main__:  Part 1 min cost: (350, 345035)
2022-01-12 13:57:56.461:INFO:__main__:  Part 2 min cost: (478, 97038163)
2022-01-12 13:57:56.461:INFO:__main__:  Execution time: 0.5585 seconds
```

## Solution #2

Here we're going to use both [NumPy](https://numpy.org/devdocs/user/quickstart.html){:target="_blank"} and [SciPy](https://docs.scipy.org/doc/scipy/tutorial/general.html){:target="_blank"}. This makes for much shorter code!



```python
import logging
import os
import time
import numpy as np
from scipy import optimize

SCRIPT_DIR = os.path.dirname(__file__) 
INPUT_FILE = "input/input.txt"
# INPUT_FILE = "input/sample_input.txt"

logging.basicConfig(format="%(asctime)s.%(msecs)03d:%(levelname)s:%(name)s:\t%(message)s", 
                    datefmt='%H:%M:%S')
logger = logging.getLogger(__name__)
logger.setLevel(level=logging.DEBUG)

input_file = os.path.join(SCRIPT_DIR, INPUT_FILE)
data: np.ndarray = np.loadtxt(input_file, delimiter=",", dtype=np.int32)

# minimize_scaler expects the function as first param, and args are any additional params the func requires
cost_part_1 = optimize.minimize_scalar(cost, args=(data))
logger.info("Part 1 min cost: %s", round(cost_part_1.fun))

cost_part_2 = optimize.minimize_scalar(cost, args=(data, lambda n: n*(n+1)/2))
logger.info("Part 2 min cost: %s", round(cost_part_2.fun)) 

def cost(posn: int, data: np.ndarray, cost_func=lambda n: n) -> int:
    """ Return the sum of applying the cost_func to get to position n, for every item in the array. """
    return cost_func(np.abs(posn-data)).sum()
```

Output:

```
2022-01-12 19:48:56.137:INFO:__main__:  Part 1 min cost: 345035
2022-01-12 19:48:56.137:INFO:__main__:  Part 2 min cost: 97038064
2022-01-12 19:48:56.137:INFO:__main__:  Execution time: 0.0033 seconds
```

Same answer, but over 100x faster!