---
day: 12
title: Day 12
problem: Passage Pathing
main_img:
  name: Cave network
  link: /assets/images/caves.jpg
tags: 
  - name: Breadth First Search (BFS)
    link: https://www.redblobgames.com/pathfinding/a-star/introduction.html
  - name: pathlib
    link: https://medium.com/@ageitgey/python-3-quick-tip-the-easy-way-to-deal-with-file-paths-on-windows-mac-and-linux-11a072b58d5f
  - name: graphs
    link: https://en.wikipedia.org/wiki/Graph_(abstract_data_type)
  - name: networkx
    link: https://networkx.org/
  - name: matplotlib
    link: https://matplotlib.org/
  - name: visualisation
---

## Solution Intro

I enjoyed this one. There are a couple of ways of going about the problem, and I ended up writing three different solutions.

- [Solution #1](#solution-1) - Using the Parsimonious PEG Library
- [Solution #2](#solution-2) - Writing my own parser

We're told that our sub's navigation data is corrupted. The navigation is our input data, and it looks like this:

```
[({(<(())[]>[[{[]{<()<>>
[(()[<>])]({[<{<<[]>>(
{([(<{}[<>[]}>{[]{[(<()>
(((({<>}<{<{<>}{[]{[]{}
[[<[([]))<([[{}[[()]]]
...
```

- Each line contains one or more navigation _chunks_. 
- Chunks open and close with matching brackets.
- Valid brackets are any of (), <>, {}, and [].
- Each chunk contains zero or more inner chunks.

We're told some lines are incomplete, whilst some are corrupted.

- Corrupt lines will have a closing bracket in the wrong place. I.e. because a different closing bracket is expected. For example, `"{()()()>"` must be corrupt, because we have a `>` without a corresponding `<`.
- Incomplete lines do not have any closing brackets in the wrong place.  But there are chunks still open, and thus missing appropriate closing brackets. For example, `"{<<[]>>("` must be incomplete, because the last `(` has not been closed, nor has the `{`.

## Solution #1

My first solution uses the very cool [Parsimonious](https://pypi.org/project/parsimonious/){:_target="_blank"}. This is a library that allows the parsing of grammars, i.e. a set of terms that follow a defined set of rules. Think of it like regex on steroids, since it has the ability to recognise specific language terms, but also recurse into those terms.

### Part 1

We're ignoring incomplete lines. We're told to find the first invalid chracter in each corrupted line, and determine its score.  Each type of invalid character maps to one of four unique scores. Then we're asked to add up these scores, to give the _total syntax error score_.

### Setup

Let's import what we need:

```python
from collections import defaultdict
import logging
import os
import time
from parsimonious import Grammar, ParseError
from parsimonious.exceptions import IncompleteParseError

SCRIPT_DIR = os.path.dirname(__file__) 
INPUT_FILE = "input/input.txt"
# INPUT_FILE = "input/sample_input.txt"

logging.basicConfig(format="%(asctime)s.%(msecs)03d:%(levelname)s:%(name)s:\t%(message)s", 
                    datefmt='%Y-%m-%d %H:%M:%S')
logger = logging.getLogger(__name__)
logger.setLevel(level=logging.INFO)
```

### The solution

Let's define our `Parsimonious Grammar`, i.e. the set of rules that determine whether our input is valid.

We sort the scores, and then identify the median, as required.

The output looks like this:

```
2022-01-15 20:12:37.680:INFO:__main__:  Part 1: There are 49 corrupted lines
2022-01-15 20:12:37.681:INFO:__main__:  Syntax error score=339477

2022-01-15 20:12:37.682:INFO:__main__:  Part 2: There are 49 remaining incomplete lines
2022-01-15 20:12:37.686:INFO:__main__:  Completion score=3049320156
2022-01-15 20:12:37.687:INFO:__main__:  Execution time: 0.0664 seconds
```

## Solution #2

Parsimonious is awesome, and we can give it any rules we want it to follow.  But it does come with a bit of processing overhead.  If we want to be super-quick, we can write our own parser.  So that's what I've done here. It also gives us a bit of practice at writing our own user-defined exceptions.

First, Part 1:

### Setup

These are the imports we need:

```python
import logging
import os
import time
from collections import deque
from dataclasses import dataclass
```

And we'll still use these constants:

```python
OPENERS = ["(", "[", "{", "<"]
CLOSERS = [")", "]", "}", ">"]
OPEN_TO_CLOSE = dict(zip(OPENERS, CLOSERS))  # {'(': ')', ...}

COMPLETION_CHAR_SCORES = dict(zip(CLOSERS, (1, 2, 3, 4)))
INVALID_CHAR_SCORES = dict(zip(CLOSERS, (3, 57, 1197, 25137)))
```

### Solution

And we'll create a user-defined `ParseException`, by subclassing `Exception`. Note that we also make it a `dataclass`, so we don't need to create an `__init__()` method to initialise any variables.

```python
@dataclass
class ParseException(Exception):
    """ Data parsed and found to be invalid """
    expected: str
    actual: str
```

Now, for each line, we parse using this function:
    
# Part 2
completion_scores.sort()
logger.info("Part 2: Completion score=%d", completion_scores[len(completion_scores)//2])
```

And this is about 300x faster:

```
2022-01-15 20:35:23.126:INFO:__main__:  Part 1: There are 49 corrupted lines
2022-01-15 20:35:23.127:INFO:__main__:  Syntax error score=339477

2022-01-15 20:35:23.127:INFO:__main__:  Part 2: Completion score=3049320156
2022-01-15 20:35:23.128:INFO:__main__:  Execution time: 0.0021 seconds
```
