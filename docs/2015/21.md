---
day: 21
title: Day 21
main_img:
  name: "RPG Fight"
  link: /assets/images/rpg-fight.jpg
tags: 
  - name: Dataclass
    link: /python/classes#dataclass
  - name: Regex
    link: /python/regex
  - name: splat
    link: /python/zip#unpacking-an-arbitrary-number-of-iterables
  - name: Classes
    link: /python/classes
---

## Page Navigation

- [Problem Intro](#problem-intro)
- [Part 1](#part-1)
- [Part 2](#part-2)
- [Results](#results)

## Problem Intro

We need win an RPG computer game match. 

We alternative taking turns with the CPU.  The CPU is playing the boss. The current player attacks on their turn.
- The attack reduces the opponent's hit points.
- The loser is player whose hit points reach 0 (or lower).
- `Damage taken = attacker's damage - defender's armor`, with a minimum of 1.
- Damage and armor score start at 0 and can be increased by buying items from the shop, in exchange for gold. Gold is unlimited.

The shop's products are given to us:

```text
Weapons:    Cost  Damage  Armor
Dagger        8     4       0
Shortsword   10     5       0
Warhammer    25     6       0
Longsword    40     7       0
Greataxe     74     8       0

Armor:      Cost  Damage  Armor
Leather      13     0       1
Chainmail    31     0       2
Splintmail   53     0       3
Bandedmail   75     0       4
Platemail   102     0       5

Rings:      Cost  Damage  Armor
Damage +1    25     1       0
Damage +2    50     2       0
Damage +3   100     3       0
Defense +1   20     0       1
Defense +2   40     0       2
Defense +3   80     0       3
```

Shop rules:
- We must buy exactly one weapon.
- We can buy one armor item.
- We can buy 0, 1, or 2 rings.
- The shop only has one of each item.

**We start with 100 hit points. Our damage and armor scores are given by the sum of the respective values of the items we have bought. Our opponent's starting hit points, damage and armor scores are given to us as input.** E.g.

```text
Hit Points: 104
Damage: 8
Armor: 1
```

## Part 1

**What is the least amount of gold you can spend and still win the fight?**

Let's start with the easy part: reading in the shop information. I copied the shop text into a file, because I didn't know if the shop data might change for Part 2. 

First, I create a dataclass to store each row read from the file.

```python
@dataclass(frozen=True)
class Item:
    """ Immutable class for the properties of shop items """
    name: str
    cost: int
    damage: int
    armor: int
```

Then, I read the shop data using [regex](/python/regex), as follows:

```python
def process_shop_items(data) -> tuple[dict, dict, dict]:
    """ Process shop items and return tuple of weapons, armor and rings.
    Each tuple member is a dict, mapping a shop item to its properties (name, cost, damage, armor).

    Args:
        data (List[str]): Lines from the shop file

    Returns:
        Tuple[dict, dict, dict]: Dictionaries of weapons, armor and rings. 
                                 Each dict is a mapping of item name to an Item object.
    """
    # e.g. "Damage +1    25     1       0"
    item_match = re.compile(r"^(.*)\s{2,}(\d+).+(\d+).+(\d+)")

    weapons = {}
    armor = {}
    rings = {}

    block = ""
    for line in data:
        if "Weapons:" in line:
            block = "weapons"
        elif "Armor:" in line:
            block = "armor"
        elif "Rings:" in line:
            block = "rings"
        else: # we're processing items listed in the current block type
            match = item_match.match(line)
            if match:
                item_name, cost, damage_score, armor_score = match.groups()
                item_name = item_name.strip()
                cost, damage_score, armor_score = int(cost), int(damage_score), int(armor_score)
                if block == "weapons":
                    weapons[item_name] = Item(item_name, cost, damage_score, armor_score)
                elif block == "armor":
                    armor[item_name] = Item(item_name, cost, damage_score, armor_score)
                elif block == "rings":
                    rings[item_name] = Item(item_name, cost, damage_score, armor_score)

    return weapons, armor, rings
```

The regex works as follows:

- `^` denotes the start of the line.
- `(.*)` captures any sequence of characters. The `.*` means "any character (.) repeated zero or more times (*)". The parentheses are used to create a capturing group, which allows this sequence of characters to be extracted later. This is how we capture the name of the item.
- `\s{2,}` matches two or more whitespace characters. `\s` represents a whitespace character and `{2,}` means "match at least 2 of the preceding element". This allows the pattern to skip over an area of the string that contains at least two spaces.
- `(\d+)` captures one or more digit characters. `\d` represents any digit (0-9) and `+` means "one or more of the preceding element". This is another capturing group, and is used to capture the `Cost`.
- `.+(\d+).(+\d+)` matches one or more of any character (which is ignored), followed by one or more digits, followed again by one or more of any character (which is ignored), and finally ending with one or more digits. The digits are expected to be captured. They represent the `Damage` and `Armor`.

We read the input file one line at a time. And whenever we read a "header" row (i.e. containing `Weapons`, `Armor`, or `Rings`), we set a variable accordingly, and use this to add all subsequent items found to the appropriate `dictionary`. In each case, we take the current row, and use it to build an `Item` object, containing the attributes for a given item. We return the results as a `tuple` of three dictionaries.

We call this from our `main()` method like this:

```python
    # Shop contructor takes multiple params.  Splat the tuple to pass these in.
    shop = Shop(*process_shop_items(data))
```

This line is interesting, because I'm using the [splat](/python/zip#unpacking-an-arbitrary-number-of-iterables) operator to unpack the returned `tuple` to its three constituent dictionaries, and passes these into the `__init__()` method of our my `Shop` class.  More on that class later.

Now, let's look at my `Loadout` class:

```python
class Loadout:
    """ A valid combination of weapon, armor, and rings. """
    
    def __init__(self, item_names: list, items: list):
        """ Initialise a loadout.

        Args:
            item_names (list): A list of item names
            items (list): _description_
        """
        self._item_names = item_names # E.g. ['Dagger', None, 'Damage +1', 'Damage +2']
        self._items = items # The Items
        self._cost = 0 # computed
        self._damage = 0 # computed
        self._armor = 0 # computed
        self._compute_attributes()

    @property
    def cost(self) -> int:
        return self._cost

    @property
    def damage(self) -> int:
        return self._damage

    @property
    def armor(self) -> int:
        return self._armor

    def _compute_attributes(self):
        """ Compute the total cost, damage and armor of this Loadout """
        an_item:Item
        for an_item in self._items:
            self._cost += an_item.cost
            self._damage += an_item.damage
            self._armor += an_item.armor

    def __repr__(self):
        return f"Loadout: {self._item_names}, cost: {self._cost}, damage: {self._damage}, armor: {self._armor}"
```

A few notes about this class:

- When initialising, we pass in a `list` of item names, and a corresponding `list` of Items.
- We then call `self._compute_attributes()` to compute the attributes of this `Loadout`, i.e. the total `cost`, `damage` and `armor` values of this `Loadout`.  Note how this method starts with `_`, indicating that it is intended to be a _private_ method, and should only be used by the internal implementation of this class.  This method should not be called from outside the class.
- The `self._compute_attributes()` method iterates through the `Item` objects, and incrementally updates the attributes each time.
- Note that I expose the `cost`, `damage` and `armor` attributes as _properties_, using the `@property` decorator.

I've defined a `Loadout` to be any valid combination of _weapon_, _armor_ and _rings_.

Finally, let's look at the `Shop` class:

```python
class Shop:
    """ Represents all the items that can be bought in the shop """

    def __init__(self, weapons: dict, armor: dict, rings: dict):
        """ Stores all_items as a dict to map the item name to the properties.
        Then computes all valid combinations of items, as 'loadouts'
        """
        self._all_items = weapons | armor | rings # merge dictionaries
        
        self._weapons = weapons # {'Dagger': Item(name='Dagger', cost=8, damage=4, armor=0)}
        self._armor = armor     # {'Leather': Item(name='Leather', cost=13, damage=0, armor=1)}
        self._rings = rings     # {'Damage +1': }
        
        self._loadouts = self._create_loadouts()

    def _create_loadouts(self):
        """ Computes all valid loadouts, given the items available in the shop. Rules:
            - All loadouts have one and only one weapon
            - Loadouts can have zero or one armor
            - Loadouts can have zero, one or two rings.  (But each ring can only be used once.)
        """
        loadouts = []        
        weapon_options = list(self._weapons) # Get a list of the weapon names
        armor_options = [None] + list(self._armor) # Get a list of the armor names

        # build up the ring options.  Start by adding zero or one ring options.
        # E.g. [[None], [Damage +1], [Damage +2]...]
        ring_options = [[None]] + [[ring] for ring in self._rings] 
        # And now add combinations (without duplicates) if using two rings
        for combo in combinations(self._rings, 2):
            ring_options.append([combo[0], combo[1]]) # Append, e.g. ['Damage +1', 'Damage +2']

        # Now we have 5 weapons, 5 armors, and 22 different ring combos
        # smash our valid options together to get a list with three items
        # Then perform cartesian product to get all ways of combining these three lists (= 550 combos)
        all_items = [weapon_options, armor_options, ring_options]
        all_loadouts_combos: list[tuple] = list(itertools.product(*all_items))

        # Our product is a tuple with always three items, which looks like (weapon, armor, [rings])
        # Where [rings] can have [None], one or two rings.  
        # We need to expand flatten this list, into... [weapon, armor, ring1...]
        for weapon, armor, rings in all_loadouts_combos: # e.g. ('Dagger', 'Leather', [None])
            loadout_item_names = []
            loadout_item_names = [weapon] + [armor] + [ring for ring in rings]

            # now use the item name to retrieve the actual items for this loadout
            items = []
            for item_name in loadout_item_names:
                if item_name is not None:
                    an_item = self._all_items[item_name]
                    items.append(an_item)

            # And build a Loadout object, passing in the item names (for identification) and the items themselves
            loadout = Loadout(loadout_item_names, items)
            loadouts.append(loadout)
        
        return loadouts

    def get_loadouts(self) -> list[Loadout]:
        """ Get the valid loadouts that can be assembled from shop items """
        return self._loadouts
```

<img src="{{'/assets/images/elf_delivery_pt1_output.png' | relative_url }}" alt="Elf drops, Part 1" width="640px" />


## Part 2

<img src="{{'/assets/images/elf_delivery_pt2_output.png' | relative_url }}" alt="Elf drops, Part 2" width="720px" />

## Results
