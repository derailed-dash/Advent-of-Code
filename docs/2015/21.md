---
day: 21
title: Day 21
main_img:
  name: "RPG Fight"
  link: /assets/images/rpg-fight.jpg
tags: 
  - name: Dataclass
    link: /python/classes#dataclass
  - name: Regex
    link: /python/regex
---

## Page Navigation

- [Problem Intro](#problem-intro)
- [Part 1](#part-1)
- [Part 2](#part-2)
- [Results](#results)

## Problem Intro

We need win an RPG computer game match. 

We alternative taking turns with the CPU.  The CPU is playing the boss. The current player attacks on their turn.
- The attack reduces the opponent's hit points.
- The loser is player whose hit points reach 0 (or lower).
- `Damage taken = attacker's damage - defender's armor`, with a minimum of 1.
- Damage and armor score start at 0 and can be increased by buying items from the shop, in exchange for gold. Gold is unlimited.

The shop's products are given to us:

```text
Weapons:    Cost  Damage  Armor
Dagger        8     4       0
Shortsword   10     5       0
Warhammer    25     6       0
Longsword    40     7       0
Greataxe     74     8       0

Armor:      Cost  Damage  Armor
Leather      13     0       1
Chainmail    31     0       2
Splintmail   53     0       3
Bandedmail   75     0       4
Platemail   102     0       5

Rings:      Cost  Damage  Armor
Damage +1    25     1       0
Damage +2    50     2       0
Damage +3   100     3       0
Defense +1   20     0       1
Defense +2   40     0       2
Defense +3   80     0       3
```

Shop rules:
- We must buy exactly one weapon.
- We can buy one armor item.
- We can buy 0, 1, or 2 rings.
- The shop only has one of each item.

**We start with 100 hit points. Our damage and armor scores are given by the sum of the respective values of the items we have bought. Our opponent's starting hit points, damage and armor scores are given to us as input.** E.g.

```text
Hit Points: 104
Damage: 8
Armor: 1
```

## Part 1

**What is the least amount of gold you can spend and still win the fight?**

Let's start with the easy part: reading in the shop information. I copied the shop text into a file, because I didn't know if the shop data might change for Part 2. 

First, I create a dataclass to store each row read from the file.

```python
@dataclass(frozen=True)
class Item:
    """ Immutable class for the properties of shop items """
    name: str
    cost: int
    damage: int
    armor: int
```

Then, I read the shop data using [regex](/python/regex), as follows:

```python
def process_shop_items(data) -> tuple[dict, dict, dict]:
    """ Process shop items and return tuple of weapons, armor and rings.
    Each tuple member is a dict, mapping a shop item to its properties (name, cost, damage, armor).

    Args:
        data (List[str]): Lines from the shop file

    Returns:
        Tuple[dict, dict, dict]: Dictionaries of weapons, armor and rings. 
                                 Each dict is a mapping of item name to an Item object.
    """
    # e.g. "Damage +1    25     1       0"
    item_match = re.compile(r"^(.*)\s{2,}(\d+).+(\d+).+(\d+)")

    weapons = {}
    armor = {}
    rings = {}

    block = ""
    for line in data:
        if "Weapons:" in line:
            block = "weapons"
        elif "Armor:" in line:
            block = "armor"
        elif "Rings:" in line:
            block = "rings"
        else: # we're processing items listed in the current block type
            match = item_match.match(line)
            if match:
                item_name, cost, damage_score, armor_score = match.groups()
                item_name = item_name.strip()
                cost, damage_score, armor_score = int(cost), int(damage_score), int(armor_score)
                if block == "weapons":
                    weapons[item_name] = Item(item_name, cost, damage_score, armor_score)
                elif block == "armor":
                    armor[item_name] = Item(item_name, cost, damage_score, armor_score)
                elif block == "rings":
                    rings[item_name] = Item(item_name, cost, damage_score, armor_score)

    return weapons, armor, rings
```

The regex works as follows:

- `^` denotes the start of the line.
- `(.*)` captures any sequence of characters. The `.*` means "any character (.) repeated zero or more times (*)". The parentheses are used to create a capturing group, which allows this sequence of characters to be extracted later. This is how we capture the name of the item.
- `\s{2,}` matches two or more whitespace characters. `\s` represents a whitespace character and `{2,}` means "match at least 2 of the preceding element". This allows the pattern to skip over an area of the string that contains at least two spaces.
- `(\d+)` captures one or more digit characters. `\d` represents any digit (0-9) and `+` means "one or more of the preceding element". This is another capturing group, and is used to capture the `Cost`.
- `.+(\d+).(+\d+)` matches one or more of any character (which is ignored), followed by one or more digits, followed again by one or more of any character (which is ignored), and finally ending with one or more digits. The digits are expected to be captured. They represent the `Damage` and `Armor`.

We read the input file one line at a time. And whenever we read a "header" row (i.e. containing `Weapons`, `Armor`, or `Rings`), we set a variable accordingly, and use this to add all subsequent items found to the appropriate `dictionary`. In each case, we take the current row, and use it to build an `Item` object, containing the attributes for a given item.

<img src="{{'/assets/images/elf_delivery_pt1_output.png' | relative_url }}" alt="Elf drops, Part 1" width="640px" />


## Part 2

<img src="{{'/assets/images/elf_delivery_pt2_output.png' | relative_url }}" alt="Elf drops, Part 2" width="720px" />

## Results
